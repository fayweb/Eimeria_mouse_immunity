Parasite_primary == "E_ferrisi" & Parasite_challenge == "E_ferrisi" ~ "ferrisi_ferrisi",
Parasite_primary == "E_ferrisi" & Parasite_challenge == "uninfected" ~ "ferrisi_uninfected",
TRUE ~ ""))
### Add the variable end weight (relative weight at day of sacrifice)
# start by adding the variable dpi_max which inficates the last day of each mouse
Challenge <- Challenge %>%
dplyr::filter(!weight == "NA") %>%
dplyr::group_by(EH_ID, infection) %>%
dplyr::mutate(dpi_max = max(dpi))
#somehow case when dplyr ways didn't work for me and this is the only solution
#that is functional
#let's filter for the challenge mice
chal <- Challenge %>% filter(infection == "challenge")
#now only select the rows where the dpi is equal to the dpi max for each mouse
chal <- chal[chal$dpi == chal$dpi_max, ]
#now we can easily add the variable end weight to each mouse (which in now equal
#to the weight on the dpi = dpi_max)
chal <- chal %>% dplyr::mutate(end_rel_weight = (weight/weight_dpi0) * 100)
#let'repeat for the prim
#let's filter for the challenge mice
prim <- Challenge %>% filter(infection == "primary")
#now only select the rows where the dpi is equal to the dpi max for each mouse
prim <- prim[prim$dpi == prim$dpi_max, ]
#now we can easily add the variable end weight to each mouse (which in now equal
#to the weight on the dpi = dpi_max)
prim <- prim %>%
dplyr::mutate(end_rel_weight = (weight/weight_dpi0) * 100)
c <- rbind(chal, prim)
#now jon it to the challenge infections
c %>%
dplyr::select(EH_ID, end_rel_weight) %>%
right_join(Challenge) -> Challenge
Challenge <- unique(Challenge)
gene <- as_tibble(Challenge) %>%
dplyr::filter(infection == "challenge", dpi == dpi_max) %>%
dplyr::group_by(EH_ID) %>%
dplyr::select(c(EH_ID, Eim_MC, all_of(Genes_refe)))
gene <- unique(gene)
gene1 <- gene
#create calibrator samples for the analysis
# create new columns with the minimum of each gene
# which I will use as the calibrator sample
#create a function which gives you the PPIB value for the minimum value of a gene
Dct_Calibrator <- function(x) {
h <-  gene[which(gene[[x]] == min(gene[[x]], na.rm = TRUE)), ][,c(x, "PPIB")]
h[[x]] - h[["PPIB"]]
}
#Apply the function to all genes
Calibrator_values <- as.data.frame(unlist(lapply(Genes, Dct_Calibrator)))
Calibrator_values <- cbind(Calibrator_values, as.data.frame(Genes))
Calibrator_values <- Calibrator_values %>%
rename(Dct.calibrator = "unlist(lapply(Genes, Dct_Calibrator))")
Calibrator_values <- Calibrator_values %>% pivot_wider(names_from = Genes, values_from = Dct.calibrator)
gene <- gene %>%
dplyr::mutate(IFNy_N = 2^- ((IFNy - PPIB) - Calibrator_values[["IFNy"]]),
CXCR3_bio_N  = 2^- ((CXCR3_bio - PPIB)- Calibrator_values[["CXCR3_bio"]]),
IL.6_N = 2^-((IL.6 - PPIB)- Calibrator_values[["IL.6"]]),
IL.10_N = 2^-((IL.10 - PPIB)- Calibrator_values[["IL.10"]]),
IL.13_N = 2^-((IL.13 - PPIB)- Calibrator_values[["IL.13"]]),
IL1RN_N = 2^-((IL1RN - PPIB)- Calibrator_values[["IL1RN"]]),
CASP1_N = 2^-((CASP1 - PPIB)- Calibrator_values[["CASP1"]]),
CXCL9_N  = 2^-((CXCL9 - PPIB)- Calibrator_values[["CXCL9"]]),
IDO1_N = 2^-((IDO1 - PPIB)- Calibrator_values[["IDO1"]]),
IRGM1_N = 2^-(( IRGM1 - PPIB)- Calibrator_values[["IRGM1"]]),
MPO_N  =  2^-((MPO - PPIB) - Calibrator_values[["MPO"]]),
MUC2_N = 2^-((MUC2 - PPIB)- Calibrator_values[["MUC2"]]),
MUC5AC_N = 2^-((MUC5AC - PPIB)- Calibrator_values[["MUC5AC"]]),
MYD88_N  = 2^-((MYD88 - PPIB)- Calibrator_values[["MYD88"]]),
NCR1_N  = 2^-((NCR1 - PPIB)- Calibrator_values[["NCR1"]]),
PRF1_N = 2^-((PRF1 - PPIB)- Calibrator_values[["PRF1"]]),
RETNLB_N =  2^-((RETNLB - PPIB)- Calibrator_values[["RETNLB"]]),
SOCS1_N = 2^-((SOCS1 - PPIB)- Calibrator_values[["SOCS1"]]),
TICAM1_N  = 2^-((TICAM1 - PPIB)- Calibrator_values[["TICAM1"]]),
TNF_N = 2^-((TNF - PPIB) - Calibrator_values[["TNF"]]))
#create a new vector for selecting genes
genes_N <- c("IFNy_N", "CXCR3_bio_N", "IL.6_N", "IL.10_N", "IL.13_N", "IL1RN_N",
"CASP1_N", "CXCL9_N", "IDO1_N", "IRGM1_N", "MPO_N", "MUC2_N", "MUC5AC_N", "MYD88_N",
"NCR1_N", "PRF1_N", "RETNLB_N", "SOCS1_N", "TICAM1_N", "TNF_N")
# turn the data frame into a matrix and transpose it. We want to have each cell
# type as a row name
gene <- t(as.matrix(gene1 %>% dplyr::select(c(EH_ID, all_of(Genes)))))
#switch the matrix back to a data frame format
gene <- as.data.frame(gene)
# turn the first row into column names
gene %>%
row_to_names(row_number = 1) -> heatmap_data
table(rowSums(is.na(heatmap_data)) == nrow(heatmap_data))
# turn the columns to numeric other wise the heatmap function will not work
heatmap_data[] <- lapply(heatmap_data, function(x) as.numeric(as.character(x)))
# remove columns with only NAs
heatmap_data <- Filter(function(x)!all(is.na(x)), heatmap_data)
#remove rows with only Nas
heatmap_data <-  heatmap_data[, colSums(is.na(heatmap_data)) != nrow(heatmap_data)]
### Prepare the annotation data frame for the heatmap
annotation_df <- as_tibble(Challenge) %>%
dplyr::filter(infection == "challenge", dpi == dpi_max) %>%
dplyr::group_by(EH_ID) %>%
dplyr::select(c("EH_ID", "Parasite_challenge", "infection_history","mouse_strain",
"max_WL", "delta", "hybrid_status")) %>%
dplyr::filter(EH_ID %in% colnames(heatmap_data))
annotation_df <- unique(annotation_df)
annotation_df <- as.data.frame(unique(annotation_df)) %>%
dplyr::select(-EH_ID)
### Prepare the annotation columns for the heatmap
rownames(annotation_df) <- annotation_df$EH_ID
# Match the row names to the heatmap data frame
rownames(annotation_df) <- colnames(heatmap_data)
pheatmap(heatmap_data, annotation_col = annotation_df, scale = "row")
gene_correlation <- gene1 %>%
ungroup() %>%
dplyr::select(all_of(Genes))
# draw correlation between the genes
gene_correlation <- as.matrix(cor(gene_correlation, use="pairwise.complete.obs"))
# load the function to calculate the p value for correlations
source("r_scripts/functions/p_value_for_correlations.R")
getwd()
setwd("~/GitHub/Eimeria_mouse_immunity")
knitr::opts_chunk$set(echo = TRUE)
library(pheatmap)
library(tidyverse)
library(matrixStats)
library(tidyr)
library(janitor)
library(tibble)
library(corrplot)
library(RColorBrewer)
library(ggplot2)
library(dplyr)
library(missMDA)
library(FactoMineR)
library(PerformanceAnalytics)
library(factoextra)
library(MASS)
library(reshape2)
library(cowplot)
library(lmtest)
library(optimx)
if(any(grepl("package:plyr", search()))) detach("package:plyr") else message("plyr not loaded")
### Import the data
Challenge <- read.csv("https://raw.githubusercontent.com/derele/Eimeria_Lab/master/data_products/Challenge_infections.csv")
# Vector for selecting genes
Genes <- c("IFNy", "CXCR3_bio", "IL.6", "IL.10", "IL.13","IL1RN",
"CASP1", "CXCL9", "IDO1", "IRGM1", "MPO", "MUC2", "MUC5AC", "MYD88",
"NCR1", "PRF1", "RETNLB", "SOCS1", "TICAM1", "TNF")
Genes_refe <- c("IFNy", "CXCR3_bio", "IL.6", "IL.10", "IL.13", "IL1RN",
"CASP1", "CXCL9", "IDO1", "IRGM1", "MPO", "MUC2", "MUC5AC", "MYD88",
"NCR1", "PRF1", "RETNLB", "SOCS1", "TICAM1", "TNF", "PPIB")
Challenge <- Challenge %>%
dplyr::mutate(Parasite_primary = case_when(
primary_infection == "E64" ~ "E_ferrisi",
primary_infection == "E88" ~ "E_falciformis",
primary_infection == "Eflab" ~ "E_falciformis",
primary_infection == "E139" ~ "E_ferrisi",
primary_infection == "UNI" ~ "uninfected",
TRUE ~ ""))
Challenge <- Challenge %>%
dplyr::mutate(Parasite_challenge = case_when(
challenge_infection == "E64" ~ "E_ferrisi",
challenge_infection == "E88" ~ "E_falciformis",
challenge_infection == "Eflab" ~ "E_falciformis",
challenge_infection == "E139" ~ "E_ferrisi",
challenge_infection == "UNI" ~ "uninfected",
TRUE ~ ""))
Challenge <- Challenge %>%
dplyr::mutate(infection_history = case_when(
Parasite_primary == "uninfected" & Parasite_challenge == "uninfected" ~ "uninfected",
Parasite_primary == "uninfected" & Parasite_challenge == "E_ferrisi" ~ "uninfected_ferrisi",
Parasite_primary == "uninfected" & Parasite_challenge == "E_falciformis" ~ "uninfected_falciformis",
Parasite_primary == "E_falciformis" & Parasite_challenge == "E_falciformis" ~ "falciformis_falciformis",
Parasite_primary == "E_falciformis" & Parasite_challenge == "E_ferrisi" ~ "falciformis_ferrisi",
Parasite_primary == "E_falciformis" & Parasite_challenge == "uninfected" ~ "falciformis_uninfected",
Parasite_primary == "E_ferrisi" & Parasite_challenge == "E_falciformis" ~ "ferrisi_falciformis",
Parasite_primary == "E_ferrisi" & Parasite_challenge == "E_ferrisi" ~ "ferrisi_ferrisi",
Parasite_primary == "E_ferrisi" & Parasite_challenge == "uninfected" ~ "ferrisi_uninfected",
TRUE ~ ""))
### Add the variable end weight (relative weight at day of sacrifice)
# start by adding the variable dpi_max which inficates the last day of each mouse
Challenge <- Challenge %>%
dplyr::filter(!weight == "NA") %>%
dplyr::group_by(EH_ID, infection) %>%
dplyr::mutate(dpi_max = max(dpi))
#somehow case when dplyr ways didn't work for me and this is the only solution
#that is functional
#let's filter for the challenge mice
chal <- Challenge %>% filter(infection == "challenge")
#now only select the rows where the dpi is equal to the dpi max for each mouse
chal <- chal[chal$dpi == chal$dpi_max, ]
#now we can easily add the variable end weight to each mouse (which in now equal
#to the weight on the dpi = dpi_max)
chal <- chal %>% dplyr::mutate(end_rel_weight = (weight/weight_dpi0) * 100)
#let'repeat for the prim
#let's filter for the challenge mice
prim <- Challenge %>% filter(infection == "primary")
#now only select the rows where the dpi is equal to the dpi max for each mouse
prim <- prim[prim$dpi == prim$dpi_max, ]
#now we can easily add the variable end weight to each mouse (which in now equal
#to the weight on the dpi = dpi_max)
prim <- prim %>%
dplyr::mutate(end_rel_weight = (weight/weight_dpi0) * 100)
c <- rbind(chal, prim)
#now jon it to the challenge infections
c %>%
dplyr::select(EH_ID, end_rel_weight) %>%
right_join(Challenge) -> Challenge
Challenge <- unique(Challenge)
gene <- as_tibble(Challenge) %>%
dplyr::filter(infection == "challenge", dpi == dpi_max) %>%
dplyr::group_by(EH_ID) %>%
dplyr::select(c(EH_ID, Eim_MC, all_of(Genes_refe)))
gene <- unique(gene)
gene1 <- gene
#create calibrator samples for the analysis
# create new columns with the minimum of each gene
# which I will use as the calibrator sample
#create a function which gives you the PPIB value for the minimum value of a gene
Dct_Calibrator <- function(x) {
h <-  gene[which(gene[[x]] == min(gene[[x]], na.rm = TRUE)), ][,c(x, "PPIB")]
h[[x]] - h[["PPIB"]]
}
#Apply the function to all genes
Calibrator_values <- as.data.frame(unlist(lapply(Genes, Dct_Calibrator)))
Calibrator_values <- cbind(Calibrator_values, as.data.frame(Genes))
Calibrator_values <- Calibrator_values %>%
rename(Dct.calibrator = "unlist(lapply(Genes, Dct_Calibrator))")
Calibrator_values <- Calibrator_values %>% pivot_wider(names_from = Genes, values_from = Dct.calibrator)
gene <- gene %>%
dplyr::mutate(IFNy_N = 2^- ((IFNy - PPIB) - Calibrator_values[["IFNy"]]),
CXCR3_bio_N  = 2^- ((CXCR3_bio - PPIB)- Calibrator_values[["CXCR3_bio"]]),
IL.6_N = 2^-((IL.6 - PPIB)- Calibrator_values[["IL.6"]]),
IL.10_N = 2^-((IL.10 - PPIB)- Calibrator_values[["IL.10"]]),
IL.13_N = 2^-((IL.13 - PPIB)- Calibrator_values[["IL.13"]]),
IL1RN_N = 2^-((IL1RN - PPIB)- Calibrator_values[["IL1RN"]]),
CASP1_N = 2^-((CASP1 - PPIB)- Calibrator_values[["CASP1"]]),
CXCL9_N  = 2^-((CXCL9 - PPIB)- Calibrator_values[["CXCL9"]]),
IDO1_N = 2^-((IDO1 - PPIB)- Calibrator_values[["IDO1"]]),
IRGM1_N = 2^-(( IRGM1 - PPIB)- Calibrator_values[["IRGM1"]]),
MPO_N  =  2^-((MPO - PPIB) - Calibrator_values[["MPO"]]),
MUC2_N = 2^-((MUC2 - PPIB)- Calibrator_values[["MUC2"]]),
MUC5AC_N = 2^-((MUC5AC - PPIB)- Calibrator_values[["MUC5AC"]]),
MYD88_N  = 2^-((MYD88 - PPIB)- Calibrator_values[["MYD88"]]),
NCR1_N  = 2^-((NCR1 - PPIB)- Calibrator_values[["NCR1"]]),
PRF1_N = 2^-((PRF1 - PPIB)- Calibrator_values[["PRF1"]]),
RETNLB_N =  2^-((RETNLB - PPIB)- Calibrator_values[["RETNLB"]]),
SOCS1_N = 2^-((SOCS1 - PPIB)- Calibrator_values[["SOCS1"]]),
TICAM1_N  = 2^-((TICAM1 - PPIB)- Calibrator_values[["TICAM1"]]),
TNF_N = 2^-((TNF - PPIB) - Calibrator_values[["TNF"]]))
#create a new vector for selecting genes
genes_N <- c("IFNy_N", "CXCR3_bio_N", "IL.6_N", "IL.10_N", "IL.13_N", "IL1RN_N",
"CASP1_N", "CXCL9_N", "IDO1_N", "IRGM1_N", "MPO_N", "MUC2_N", "MUC5AC_N", "MYD88_N",
"NCR1_N", "PRF1_N", "RETNLB_N", "SOCS1_N", "TICAM1_N", "TNF_N")
# turn the data frame into a matrix and transpose it. We want to have each cell
# type as a row name
gene <- t(as.matrix(gene1 %>% dplyr::select(c(EH_ID, all_of(Genes)))))
#switch the matrix back to a data frame format
gene <- as.data.frame(gene)
# turn the first row into column names
gene %>%
row_to_names(row_number = 1) -> heatmap_data
table(rowSums(is.na(heatmap_data)) == nrow(heatmap_data))
# turn the columns to numeric other wise the heatmap function will not work
heatmap_data[] <- lapply(heatmap_data, function(x) as.numeric(as.character(x)))
# remove columns with only NAs
heatmap_data <- Filter(function(x)!all(is.na(x)), heatmap_data)
#remove rows with only Nas
heatmap_data <-  heatmap_data[, colSums(is.na(heatmap_data)) != nrow(heatmap_data)]
### Prepare the annotation data frame for the heatmap
annotation_df <- as_tibble(Challenge) %>%
dplyr::filter(infection == "challenge", dpi == dpi_max) %>%
dplyr::group_by(EH_ID) %>%
dplyr::select(c("EH_ID", "Parasite_challenge", "infection_history","mouse_strain",
"max_WL", "delta", "hybrid_status")) %>%
dplyr::filter(EH_ID %in% colnames(heatmap_data))
annotation_df <- unique(annotation_df)
annotation_df <- as.data.frame(unique(annotation_df)) %>%
dplyr::select(-EH_ID)
### Prepare the annotation columns for the heatmap
rownames(annotation_df) <- annotation_df$EH_ID
# Match the row names to the heatmap data frame
rownames(annotation_df) <- colnames(heatmap_data)
pheatmap(heatmap_data, annotation_col = annotation_df, scale = "row")
gene_correlation <- gene1 %>%
ungroup() %>%
dplyr::select(all_of(Genes))
# draw correlation between the genes
gene_correlation <- as.matrix(cor(gene_correlation, use="pairwise.complete.obs"))
# load the function to calculate the p value for correlations
source("r_scripts/functions/p_value_for_correlations.R")
# matrix of the p-value of the correlatio
p.mat <- cor.mtest(gene_correlation)
corrplot(gene_correlation,
method = "circle",  #method of the plot, "color" would show colour gradient
tl.col = "black", tl.srt=45, #colour of labels and rotation
col = brewer.pal(n = 8, name ="RdYlBu"), #colour of matrix
order="hclust", #hclust reordering
p.mat = p.mat, sig.level = 0.01, insig = "blank",
addCoef.col = 'black',
number.cex=0.5) #Add significance level to the correlogram
#remove the values that are insignificant
g <-  as_tibble(Challenge) %>%
dplyr::filter(infection == "challenge", dpi == dpi_max) %>%
dplyr::group_by(EH_ID)%>%
dplyr::filter(EH_ID %in% colnames(heatmap_data)) %>%
pivot_longer(cols = all_of(Genes), names_to = "Gene", values_to = "gene_expression")
g <- unique(g)
g1 <- as_tibble(Challenge) %>%
dplyr::filter(infection == "challenge", dpi == dpi_max) %>%
dplyr::group_by(EH_ID)%>%
dplyr::filter(EH_ID %in% colnames(heatmap_data)) %>%
dplyr::select(all_of(Genes)) %>%
ungroup() %>%
dplyr::select(-EH_ID)
g1 <- unique(g1)
g %>%
filter(!Parasite_challenge == "uninfected", Eim_MC == "TRUE") %>%
ggplot(aes(x = delta, y = gene_expression, color = Parasite_challenge)) +
geom_jitter() +
facet_wrap(~ Gene, scales = "free") +
theme_light() +
labs(x = "Delta Ct, Infection intensity", y = "Gene expression",
title = "Gene expression in response to infection intensity") +
theme_bw()
g %>%
ggplot(aes(x = Parasite_challenge, y = gene_expression, color = Parasite_challenge)) +
geom_boxplot() +
geom_jitter() +
facet_wrap(~ Gene) +
theme_bw() +
labs(x = "Infection groups, E64 = E. ferrisi, E88 = E.falciformis,
UNI = Uninfected", y = "Gene expression",
title = "Gene expression in response to infection group")
g  %>%
ggplot(aes(x = gene_expression, color = challenge_infection)) +
geom_histogram(echo = FALSE)
#Make a scatter plot matrix showing the correlation coefficients between variables and the significance levels : the package PerformanceAnalytics is required.
chart.Correlation(g1, histogram=TRUE, pch=19)
## 1. Estimate the number of dimensions necessary to impute the dataset
# with the estim_ncpPCA
nb <- estim_ncpPCA(g1, scale = TRUE)
# Each observed value is removed, then imputed using ncp components
# The difference between the ovserved value and the imputed value is calculated
# ncp = 5
## 2. Imputation of the missing values using the function impute PCA
comp <- imputePCA(g1, ncp = 5, scale = TRUE) #impute the table
#head(comp$completeObs) # resulting imputed data table
# save the imputed file
imputed_gene <- as.data.frame(comp$completeObs)
# this estimate should be better than simply using the mean, beacause we've taken into account
# the links between variables and similarities between individuals in its calculation
options(ggrepel.max.overlaps = Inf) # solution to the error:
# ggrepel: 3 unlabeled data points (too many overlaps). Consider increasing max.overlaps
# for the next function
# we can now run a normal pca on the complete data set
res.pca <- PCA(comp$completeObs)
#head(summary(res.pca, nbelements = Inf)) #including all the elements
#Description of the dimensions
# We get a correlation between each variable and the first dimension
dimdesc(res.pca)
#Visualizing uncertainty due to missing data:
mi <- MIPCA(g1, scale = TRUE, ncp = 5)
plot(mi)
str(res.pca)
# extract pc scores for first two component and add to dat dataframe
g2 <- g %>%
pivot_wider(names_from = "Gene", values_from = "gene_expression") %>%
filter(EH_ID %in% colnames(heatmap_data)) %>%
filter(Position == "mLN")
g2$pc1 <- res.pca$ind$coord[, 1] # indexing the first column
g2$pc2 <- res.pca$ind$coord[, 2]  # indexing the second column
imputed_gene$pc1 <- res.pca$ind$coord[, 1]
imputed_gene$pc2 <- res.pca$ind$coord[, 2]
### join the pc1 and pc2 to the imputed data
imputed_expr <- g2 %>% left_join(imputed_gene, by = c("pc1", "pc2"),
suffix = c("_x", "_y"))
#remove all columns of the non-imputed data
imputed_expr = imputed_expr[,!grepl("_x$",names(imputed_expr))]
#remove the suffix y
colnames(imputed_expr) = gsub("_y", "", colnames(imputed_expr))
#We also need to extract the data for the variable contributions to each of the pc axes.
pca.vars <- res.pca$var$coord %>% data.frame
pca.vars$vars <- rownames(pca.vars)
pca.vars.m <- melt(pca.vars, id.vars = "vars")
source("r_scripts/functions/circle_fun.R")
circ <- circleFun(c(0,0),2,npoints = 500)
#Now we can make our initial plot of the PCA.
imputed_expr %>%
pivot_longer(cols = all_of(Genes), names_to = "Gene", values_to = "gene_expression")  %>%
ggplot(aes(x = pc1, y = pc2, color = Parasite_challenge, shape = Parasite_challenge)) +
geom_hline(yintercept = 0, lty = 2) +
geom_vline(xintercept = 0, lty = 2) +
geom_point(alpha = 0.8) +
stat_ellipse(geom="polygon", aes(fill = challenge_infection), alpha = 0.2, show.legend = FALSE,
level = 0.95) +
theme_minimal() +
theme(panel.grid = element_blank(), panel.border = element_rect(fill= "transparent"))
#It’s possible to use the function corrplot() [corrplot package] to highlight the most contributing variables for each dimension:
var.contrib <- res.pca$var$contrib
corrplot(var.contrib, is.corr=FALSE)
# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 18)
# Contributions of variables to PC2
fviz_contrib(res.pca, choice = "var", axes = 2, top = 18)
fviz_contrib(res.pca, choice = "var", axes = 1:2, top = 18)
#The most important (or, contributing) variables can be highlighted on the correlation plot as follow:
fviz_pca_var(res.pca, col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
)
# Total contribution on PC1 and PC2
fviz_contrib(res.pca, choice = "ind", axes = 1:2)
fviz_pca_biplot(res.pca,
col.ind = imputed_expr$Parasite_challenge, palette = "jco",
addEllipses = TRUE, label = "var",
col.var = "black", repel = TRUE,
legend.title = "Parasite in the challenge infection")
weight_lm <- lm(max_WL ~ pc1 + pc2 + Parasite_challenge, data = imputed_expr)
summary(weight_lm)
AIC(weight_lm)
weight_lm2 <- lm(max_WL ~ pc1 + pc2 + Parasite_challenge + hybrid_status, data = imputed_expr)
summary(weight_lm2)
AIC(weight_lm2)
weight_lm3 <- lm(max_WL ~ pc1 + pc2 + hybrid_status, data = imputed_expr)
weight_no_pc1 <- lm(max_WL ~ pc2 + hybrid_status, data = imputed_expr)
weight_no_pc2 <- lm(max_WL ~ pc1  + hybrid_status, data = imputed_expr)
weight_no_hybrid <- lm(max_WL ~ pc1 + pc2, data = imputed_expr)
lrtest(weight_lm3, weight_no_pc1)
lrtest(weight_lm3, weight_no_pc2)
lrtest(weight_lm3, weight_no_hybrid)
weight_lm3 <- lm(max_WL ~ pc1 + pc2 + hybrid_status, data = imputed_expr)
summary(weight_lm3)
AIC(weight_lm3)
weight_lm4 <- lm(max_WL ~ pc1 + pc2 + infection_history, data = imputed_expr)
summary(weight_lm4)
AIC(weight_lm4)
weight_lm_exp_only <- lm(max_WL ~ pc1 + pc2, data = imputed_expr)
summary(weight_lm_exp_only)
AIC(weight_lm, weight_lm_exp_only)
gene <- imputed_expr %>% dplyr::select(c(EH_ID, all_of(Genes)))
# turn the data frame into a matrix and transpose it. We want to have each cell
# type as a row name
gene <- t(as.matrix(gene))
#switch the matrix back to a data frame format
gene <- as.data.frame(gene)
# turn the first row into column names
gene %>%
row_to_names(row_number = 1) -> heatmap_data
table(rowSums(is.na(heatmap_data)) == nrow(heatmap_data))
# turn the columns to numeric other wise the heatmap function will not work
heatmap_data[] <- lapply(heatmap_data, function(x) as.numeric(as.character(x)))
# remove columns with only NAs
heatmap_data <- Filter(function(x)!all(is.na(x)), heatmap_data)
#remove rows with only Nas
heatmap_data <-  heatmap_data[, colSums(is.na(heatmap_data)) != nrow(heatmap_data)]
rownames(annotation_df) <- colnames(heatmap_data)
pheatmap(heatmap_data, annotation_col = annotation_df, scale = "row")
gene <- imputed_expr %>% dplyr::select(c(EH_ID, c("IFNy", "IL.13", "PRF1",
"TICAM1")))
# turn the data frame into a matrix and transpose it. We want to have each cell
# type as a row name
gene <- t(as.matrix(gene))
#switch the matrix back to a data frame format
gene <- as.data.frame(gene)
# turn the first row into column names
gene %>%
row_to_names(row_number = 1) -> heatmap_data
table(rowSums(is.na(heatmap_data)) == nrow(heatmap_data))
# turn the columns to numeric other wise the heatmap function will not work
heatmap_data[] <- lapply(heatmap_data, function(x) as.numeric(as.character(x)))
# remove columns with only NAs
heatmap_data <- Filter(function(x)!all(is.na(x)), heatmap_data)
#remove rows with only Nas
heatmap_data <-  heatmap_data[, colSums(is.na(heatmap_data)) != nrow(heatmap_data)]
annotation_df <- as_tibble(Challenge) %>%
dplyr::filter(infection == "challenge", dpi == dpi_max) %>%
dplyr::group_by(EH_ID) %>%
dplyr::select(c("EH_ID", "Parasite_challenge",
"hybrid_status")) %>%
dplyr::filter(EH_ID %in% colnames(heatmap_data))
annotation_df <- unique(annotation_df)
annotation_df <- as.data.frame(unique(annotation_df)) %>%
dplyr::select(-EH_ID)
### Prepare the annotation columns for the heatmap
rownames(annotation_df) <- annotation_df$EH_ID
rownames(annotation_df) <- colnames(heatmap_data)
pheatmap(heatmap_data, annotation_col = annotation_df, scale = "row")
#create a new variable for a hybrid index
g3 <- g2 %>%
mutate(HI = case_when(
hybrid_status == "F1 hybrid" ~ 0.5,
hybrid_status == "F0 M. m. domesticus" ~ 0,
hybrid_status == "F1 M. m. domesticus" ~ 0,
hybrid_status == "F1 M. m. musculus" ~ 1,
hybrid_status == "F0 M. m. musculus" ~ 1,
hybrid_status == "other" ~ 100,
TRUE ~ 100
))
#filter out the nmri mice
g3 <- g3 %>%
filter(!HI == 100) %>%
dplyr::mutate(max_WL = 100 - max_WL)
g3 <- g3 %>%
mutate(hybrid_status = case_when(
HI == 0.5 ~ "F1_hybrid",
HI == 0 ~"M.m.domesticus",
HI == 1 ~ "M.m.musculus"
))
g3 <- g3 %>%
mutate(Eim_MC = case_when(
Eim_MC == "TRUE" ~ "infected",
Eim_MC == "FALSE" ~ "uninfected"
))
g3$Eim_MC <- as.factor(g3$Eim_MC)
require(devtools)
devtools::install_github("alicebalard/parasiteLoad@v2.0", force = TRUE)
