TRUE ~ ""))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyr)
library(dplyr)
library(cowplot)
library(randomForest)
library(ggplot2)
library(caret)
library(VIM) # visualizing missing data
library(mice) # imputing missing data without predictors
library(ggpubr)
library(optimx)
# Here we import the cleaned data set from the previous script derived from the
# data set challenge infections
g <- read.csv("output_data/gene_expression/data_products/clean_gene_expression.csv")
setwd("GitHub/Eimeria_mouse_immunity/")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyr)
library(dplyr)
library(cowplot)
library(randomForest)
library(ggplot2)
library(caret)
library(VIM) # visualizing missing data
library(mice) # imputing missing data without predictors
library(ggpubr)
library(optimx)
# Here we import the cleaned data set from the previous script derived from the
# data set challenge infections
g <- read.csv("output_data/gene_expression/data_products/clean_gene_expression.csv")
# vectors for selecting gene columns
Genes <- c("IFNy", "CXCR3_bio", "IL.6", "IL.10", "IL.13", "IL.10", "IL.13", "IL1RN",
"CASP1", "CXCL9", "IDO1", "IRGM1", "MPO", "MUC2", "MUC5AC", "MYD88",
"NCR1", "PRF1", "RETNLB", "SOCS1", "TICAM1", "TNF")
# we need to change the  in challenge infections to a factor
g$Parasite_challenge <- as.factor(g$Parasite_challenge)
g$Eim_MC <- as.factor(g$Eim_MC)
# Here I create a new column, where we get the actual infection status
# According to the melting curve for eimeria
g <- g %>%
dplyr::mutate(current_infection = case_when(
Parasite_challenge == "E_ferrisi" & Eim_MC == "TRUE" ~ "E_ferrisi",
Parasite_challenge == "E_ferrisi" & Eim_MC == "FALSE" ~ "uninfected",
Parasite_challenge == "E_falciformis" & Eim_MC == "TRUE" ~ "E_falciformis",
Parasite_challenge == "E_falciformis" & Eim_MC == "FALSE" ~ "uninfected",
Parasite_challenge == "uninfected" & Eim_MC == "TRUE" ~ "infected_eimeria",
Parasite_challenge == "uninfected" & Eim_MC == "FALSE" ~ "uninfected",
TRUE ~ ""
))
# how to impute delta? Replacing with 0 the ones with negative melting curve
# open for other solutions!
g <- g %>%
dplyr::mutate(Intensity = case_when(
Eim_MC == "TRUE" ~ delta,
Eim_MC == "FALSE" ~ 0))
# create variable maximum weight loss instead of maximum relative weight loss
g <- g %>% dplyr::mutate(max_WL = max_WL - 100)
#Start by selecting only the genes and the maximum weight loss for each mouse
# Apparently the relative end weight doesn't work so well for predictions
g.1 <- g %>%
dplyr::select(c(max_WL, all_of(Genes)))
# to get reproducible results we use a seed
set.seed(42)
# We want the maximum weight loss to be predicted by the data ina ll of the other columns
# iter = how many random forests are needed, in theory 6 are enough
g.imputed <- rfImpute(max_WL ~ ., data = g.1, iter = 6)
g.imputed <- g.imputed %>% dplyr::select(-max_WL)
g_minus <- g %>%
dplyr::select(-all_of(Genes))
#full data set containing the imputed gene expression data
g.imputed <- cbind(g_minus, g.imputed)
g.imputed %>%
filter(infection == "challenge") %>%
group_by(Parasite_challenge) %>%
summarize(length(EH_ID))
g.imputed %>%
filter(infection == "challenge") %>%
group_by(current_infection) %>%
summarize(length(EH_ID))
#select the relevant columns:
g.imputed <- g.imputed %>%
dplyr::select(c(max_WL, all_of(Genes))) %>%
dplyr::select(- CXCR3_bio)
# split data into training and test
set.seed(123) # this will help us reproduce this random assignment
# in this way we can pick the random numbers
training.samples <- g.imputed$max_WL%>%
createDataPartition(p = .7, # this is the partiicition! In this case 0.7 = training data and 0.3 = testing
list = FALSE) # we don't want to get a list in return
train.data <- g.imputed[training.samples, ] #include all the randomly selected rows
test.data <- g.imputed[-training.samples, ]
#train the model
model <- randomForest(max_WL ~., data = train.data, proximity = TRUE,
ntree = 1000) # number of trees
print(model)
plot(model)
# number of trees with lowest MSE
which.min(model$mse)
## [1] 257
# RMSE of this optimal random forest
sqrt(model$mse[which.min(model$mse)])
## [1] 5.024738
### Visualize variable importance ----------------------------------------------
#Call importance() function on the model model to check how the attributes used as predictors affect our model
importance(model)
model$mse
## S3 method for class 'randomForest'
plot(model, type = "l", main=deparse(substitute(x)))
varImpPlot(model)
# Get variable importance from the model fit
ImpData <- as.data.frame(importance(model))
ImpData$Var.Names <- row.names(ImpData)
#ggplot(ImpData, aes(x=Var.Names, y=`%IncMSE`)) +
# geom_segment( aes(x=Var.Names, xend=Var.Names, y=0, yend=`%IncMSE`), color="skyblue") +
#geom_point(aes(size = IncNodePurity), color="blue", alpha=0.6) +
#theme_light() +
#coord_flip() +
#theme(
## legend.position="bottom",
#panel.grid.major.y = element_blank(),
#panel.border = element_blank(),
#axis.ticks.y = element_blank()
#)
#The predict() function in R is used to predict the values based on the input data.
predictions <- predict(model, test.data)
# assign test.data to a new object, so that we can make changes
result <- test.data
#add the new variable of predictions to the result object
result <- cbind(result, predictions)
#add the results to a data frame containing test data and the prediction
result <- cbind(g[row.names(result), ], predictions)
result   %>%
ggplot() +
geom_point(aes(x = predictions, y = max_WL, color = Parasite_challenge, size = delta)) +
geom_abline() +
labs(x = "Predictions: Maximum weight loss ", y = "Observed: Maximum weight loss",
title = "Predicting tolerance, Weight loss in response to immune gene expression") +
theme_bw()
g$current_infection <- as.factor(g$current_infection)
#now select the genes and the actual infection of the mice in the new mutate column
#infection
g.2 <- g %>%
dplyr::select(c(current_infection, delta, all_of(Genes)))
# to get reproducible results we use a seed
set.seed(42)
# We want the current infection to be predicted by the data ina ll of the other columns
# iter = how many random forests are needed, in theory 6 are enough
#now we can impute our data
g.imputed_parasite <- rfImpute(current_infection ~ ., data = g.2, iter = 6)
g.imputed_parasite <- g.imputed_parasite %>% dplyr::select(- current_infection)
g_minus <- g %>% dplyr::select(-c((all_of(Genes)), delta))
#full data set containing the imputed gene expression data
g.imputed_parasite <- cbind(g_minus, g.imputed_parasite)
g.imputed_parasite$current_infection <- as.factor(g.imputed_parasite$current_infection)
#select the relevant columns:
g.imputed_parasite <- g.imputed_parasite %>%
dplyr::select(c(current_infection, delta, all_of(Genes)))
# split data into training and test
set.seed(123) # this will help us reproduce this random assignment
# in this way we can pick the random numbers
training.samples_parasite <- g.imputed_parasite$current_infection%>%
createDataPartition(p = .7, # this is the partiicition! In this case 0.7 = training data and 0.3 = testing
list = FALSE) # we don't want to get a list in return
train.data_parasite <- g.imputed_parasite[training.samples, ] #include all the randomly selected rows
test.data_parasite <- g.imputed_parasite[-training.samples, ]
#train the model
model_Parasite <- randomForest(current_infection ~., data = train.data_parasite, proximity = TRUE,
ntree = 1500) # number of trees
print(model_Parasite)
plot(model_Parasite)
#The predict() function in R is used to predict the values based on the input data.
predictions_parasite <- predict(model_Parasite, test.data_parasite)
# assign test.data to a new object, so that we can make changes
result_parasite <- test.data_parasite
#add the new variable of predictions to the result object
result_parasite <- cbind(result_parasite, predictions_parasite)
#add the results to a data frame containing test data and the prediction
result_parasite <- cbind(g[row.names(result_parasite), ], predictions_parasite)
g$Parasite_challenge <- as.factor(g$Parasite_challenge)
#now select the genes and the actual infection of the mice in the new mutate column
#infection
g.2 <- g %>%
dplyr::select(c(Parasite_challenge, delta, all_of(Genes)))
# to get reproducible results we use a seed
set.seed(42)
# We want the current infection to be predicted by the data ina ll of the other columns
# iter = how many random forests are needed, in theory 6 are enough
#now we can impute our data
g.imputed_parasite <- rfImpute(Parasite_challenge ~ ., data = g.2, iter = 6)
g.imputed_parasite <- g.imputed_parasite %>% dplyr::select(- Parasite_challenge)
g_minus <- g %>% dplyr::select(-c((all_of(Genes)), delta))
#full data set containing the imputed gene expression data
g.imputed_parasite <- cbind(g_minus, g.imputed_parasite)
g.imputed_parasite$Parasite_challenge <- as.factor(g.imputed_parasite$Parasite_challenge)
#select the relevant columns:
g.imputed_parasite <- g.imputed_parasite %>%
dplyr::select(c(Parasite_challenge, Eim_MC, all_of(Genes)))
# to use in the next model
parasite_data <- g.imputed_parasite
g.imputed_parasite <- g.imputed_parasite %>%
dplyr::select(-Eim_MC)
# split data into training and test
set.seed(123) # this will help us reproduce this random assignment
# in this way we can pick the random numbers
training.samples_parasite <- g.imputed_parasite$Parasite_challenge%>%
createDataPartition(p = .7, # this is the partiicition! In this case 0.7 = training data and 0.3 = testing
list = FALSE) # we don't want to get a list in return
train.data_parasite <- g.imputed_parasite[training.samples, ] #include all the randomly selected rows
test.data_parasite <- g.imputed_parasite[-training.samples, ]
#train the model
model_Parasite <- randomForest(Parasite_challenge ~., data = train.data_parasite, proximity = TRUE,
ntree = 1500) # number of trees
print(model_Parasite)
plot(model_Parasite)
#The predict() function in R is used to predict the values based on the input data.
predictions_parasite <- predict(model_Parasite, test.data_parasite)
# assign test.data to a new object, so that we can make changes
result_parasite <- test.data_parasite
#add the new variable of predictions to the result object
result_parasite <- cbind(result_parasite, predictions_parasite)
#add the results to a data frame containing test data and the prediction
result_parasite <- cbind(g[row.names(result_parasite), ], predictions_parasite)
conf_matrix_parasite <- confusionMatrix(result_parasite$predictions_parasite, reference = result_parasite$Parasite_challenge)
print(conf_matrix_parasite)
conf_matrix_parasite$table
plt <- as.data.frame(conf_matrix_parasite$table)
plt$Prediction <- factor(plt$Prediction, levels=rev(levels(plt$Prediction)))
ggplot(plt, aes(x = Prediction, y =  Reference, fill= Freq)) +
geom_tile() + geom_text(aes(label=Freq)) +
scale_fill_gradient(low="white", high="forestgreen") +
labs(x = "Predictions",y = "Reference")
train.data_parasite %>%
group_by(Parasite_challenge) %>%
summarize(length(Parasite_challenge))
# to use in the next model
parasite_data <- parasite_data %>%
dplyr::select(-Parasite_challenge)
# split data into training and test
set.seed(123) # this will help us reproduce this random assignment
# in this way we can pick the random numbers
training.samples_melting <- parasite_data$Eim_MC%>%
createDataPartition(p = .7, # this is the partiicition! In this case 0.7 = training data and 0.3 = testing
list = FALSE) # we don't want to get a list in return
train.data_melting <- parasite_data[training.samples, ] #include all the randomly selected rows
test.data_melting <- parasite_data[-training.samples, ]
#train the model
model_melting <- randomForest(Eim_MC ~., data = train.data_melting, proximity = TRUE,
ntree = 1500) # number of trees
print(model_melting)
#The predict() function in R is used to predict the values based on the input data.
predictions_melting <- predict(model_melting, test.data_melting)
# assign test.data to a new object, so that we can make changes
result_melting <- test.data_melting
#add the new variable of predictions to the result object
result_melting <- cbind(result_melting, predictions_melting)
#add the results to a data frame containing test data and the prediction
result_melting <- cbind(g[row.names(result_melting), ], predictions_melting)
conf_matrix_melting <- confusionMatrix(result_melting$predictions_melting, reference = result_melting$Eim_MC)
print(conf_matrix_melting)
conf_matrix_melting$table
plt <- as.data.frame(conf_matrix_melting$table)
plt$Prediction <- factor(plt$Prediction, levels=rev(levels(plt$Prediction)))
ggplot(plt, aes(x = Prediction, y =  Reference, fill= Freq)) +
geom_tile() + geom_text(aes(label=Freq)) +
scale_fill_gradient(low="white", high="forestgreen") +
labs(x = "Predictions",y = "Reference")
Field <- read.csv("https://raw.githubusercontent.com/derele/Mouse_Eimeria_Field/master/data_products/SOTA_Data_Product.csv")
Field %>% summarise(length(Mouse_ID))
EqPCR.cols      <- c("delta_ct_cewe_MminusE", "MC.Eimeria", "Ct.Eimeria") #,"Ct.Mus""delta_ct_ilwe_MminusE", )
EimGeno.cols    <- c("n18S_Seq", "COI_Seq", "ORF470_Seq", "eimeriaSpecies")
Gene.Exp.cols   <- c("IFNy",  "CXCR3", "IL.6", #"GBP2", "IL.12", "IRG6",
"IL.10", "IL.13", "IL.10", "IL.13", "IL1RN",
"CXCR3", "CASP1", "CXCL9",
"IDO1", "IRGM1", "MPO", "MUC2", "MUC5AC", "MYD88",
"NCR1", "PRF1", "RETNLB", "SOCS1", "TICAM1", "TNF")
House.Keeping.cols <- c("GAPDH", "PPIB", "B.actin", "B-actin")
#which are the numbers of the columns of Field
names <- data.frame(colnames(Field))
f <- Field[ , c(76:78, 80:97)]
#how many nas in each column
sapply(f, function(x) sum(is.na(x)))
#remove rows with only nas
f <- f[rowSums(is.na(f)) != ncol(f), ]
Field <- Field %>%
dplyr::select(-c(76:78, 80:97))
#merge the data frame to keep only the selected rows
f <- merge(Field, f, by = "row.names")
library(mice)
f <- f %>% dplyr::select(-"Row.names")
#turn the eimeria species into logical
f$eimeriaSpecies <- as.factor(f$eimeriaSpecies)
field_genes <- f %>%
dplyr::select(Gene.Exp.cols)
# check the data for missing values
sapply(field_genes, function(x) sum(is.na(x)))
field_genes %>%
aggr(col = c('navyblue', 'red'), numbers = TRUE, sortVars = TRUE, labels=names(field_genes), cex.axis=.7, gap=3, ylab=c("Histogram of missing data","Pattern"))
marginplot(field_genes[c(1,2)])
# The frequency distribution of the missing cases per variable can be obtained as:
init <- mice(field_genes, maxit = 0)
# table of amount of variables with the amount of missing values
table(init$nmis)
# which method is used for imputation? In this case the package mice
# uses the default method for continuous variable,
# which is pmm, or predictive mean matching
meth <- init$method
# now impute the immune gene expression for the field and save it as the oject:
# igf
# m=5 refers to the number of imputed datasets. Five is the default value.
igf <- mice(field_genes, method = meth, m = 5, seed = 500)
summary(igf)
# to check each column with imputed data
## igf$imp$IFNy
#Now we can get back the completed dataset using the complete()
completeField <- complete(igf, 1)
xyplot(igf,IFNy ~ SOCS1 + IRGM1 + MUC2, pch=18,cex=1)
xyplot(igf,IFNy ~ IL.10 + PRF1 + CASP1, pch=18,cex=1)
densityplot(igf)
stripplot(igf, pch = 20, cex = 1.2)
# Start by selecting the columns that appear in both the training data set and the
# field data set
completeField <- completeField %>%
dplyr::select(intersect(colnames(completeField), colnames(train.data)))
set.seed(540)
#The predict() function in R is used to predict the values based on the input data.
predictions_field <- predict(model, completeField)
# assign test.data to a new object, so that we can make changes
result_field <- completeField
#add the new variable of predictions to the result object
result_field <- cbind(result_field, predictions_field)
#add the results to a data frame containing test data and the prediction
f <- f %>%
dplyr::select(-intersect(colnames(result_field), colnames(f)))
result_field <- cbind(f, result_field)
require(devtools)
devtools::install_github("alicebalard/parasiteLoad@v2.0")
#force = TRUE)
library(parasiteLoad)
result_field %>% ggplot(aes(x = predictions_field)) +
geom_histogram(binwidth = 1.5)
result_field %>%
ggplot(aes(x = HI , y = predictions_field , color = Sex)) +
geom_smooth() +
geom_point()
result_field %>%
ggplot(aes(x = Body_Length , y = predictions_field , color = Sex)) +
geom_smooth() +
geom_point()
library(fitdistrplus)
library(logspline)
result_field <- result_field %>%
dplyr::mutate(WL = predictions_field * (-1))
x <- result_field$WL
descdist(data = x, discrete = FALSE)
descdist(data = x, discrete = FALSE, #data is continuous
boot = 1000)
set.seed(10)
n = 25
size = 27
prob = .4
data = rbinom(x, size = size, prob = prob)
fit = fitdist(data = data, dist="binom",
fix.arg=list(size = size),
start=list(prob = 0.1))
summary(fit)
plot(fit)
normal_ <- fitdist(x, "norm")
weibull_ <- fitdist(x, "weibull")
gamma_ <- fitdist(x, "gamma")
library(fitdistrplus) # evaluate distribution
# Define function to be used to test, get the log lik and aic
tryDistrib <- function(x, distrib){
# deals with fitdistr error:
fit <- tryCatch(MASS::fitdistr(x, distrib), error=function(err) "fit failed")
return(list(fit = fit,
loglik = tryCatch(fit$loglik, error=function(err) "no loglik computed"),
AIC = tryCatch(fit$aic, error=function(err) "no aic computed")))
}
findGoodDist <- function(x, distribs, distribs2){
l =lapply(distribs, function(i) tryDistrib(x, i))
names(l) <- distribs
print(l)
listDistr <- lapply(distribs2, function(i){
if (i %in% "t"){
fitdistrplus::fitdist(x, i, start = list(df =2))
} else {
fitdistrplus::fitdist(x,i)
}}
)
par(mfrow=c(2,2))
denscomp(listDistr, legendtext=distribs2)
cdfcomp(listDistr, legendtext=distribs2)
qqcomp(listDistr, legendtext=distribs2)
ppcomp(listDistr, legendtext=distribs2)
par(mfrow=c(1,1))
}
tryDistrib(x, "normal")
tryDistrib(x, "binomial")
tryDistrib(x, "student")
tryDistrib(x, "negbin")
tryDistrib(x, "weibull")
tryDistrib(x, "weibullshifted")
findGoodDist(x, "normal", "weibull")
plot(normal_)
summary(normal_)
plot(gamma_)
summary(gamma_)
plot(weibull_)
summary(weibull_)
result_field$Sex <- as.factor(result_field$Sex)
result_field <- result_field %>%
drop_na(HI)
parasiteLoad::getParamBounds("weibull", data = result_field, response = "WL")
speparam <- c(L1start = 10,
L1LB = 1e-9,
L1UB = 20,
L2start = 10,
L2LB = 1e-9,
L2UB = 20,
alphaStart = 0, alphaLB = -5, alphaUB = 5,
myshapeStart = 1, myshapeLB = 1e-9, myshapeUB = 5)
##All
fitWL_eimeria <- parasiteLoad::analyse(data = result_field,
response = "WL",
model = "weibull",
group = "Sex")
fitWL_eimeria
parasiteLoad::analyse(data = result_field,
response = "WL",
model = "weibull",
group = "Sex")
View(g)
setwd("~/GitHub/Eimeria_Lab/")
### This could be an example of how to access particular subsets of
### the data
library(dplyr)
library(magrittr)
library(stringr)
library(ggplot2)
library(tidyr)
library(plyr)
library(data.table)
library(psych)
library(tibble)
#select columns:
basics <- c("EH_ID", "mouse_strain", "experiment", "primary_infection",
"challenge_infection", "labels", "dpi", "infection", "infection_history", "sex", "death")
weight_loss <- c("weight", "weight_dpi0", "relative_weight")
oocysts_counts <- c("feces_weight", "oocyst_sq1", "oocyst_sq2", "oocyst_sq3",
"oocyst_sq4", "dilution", "OOC", "OO4sq", "OPG_O")
intensity_qPCR <- c("Eim_MC", "delta")
cewe_elisa <- "IFNy_CEWE"
mes_elisa <- "IFNy_MES"
gene_expr <- c("CXCR3", "IRG6", "IL.12")
CellCount.cols <- c("Position", "CD4", "Treg", "Div_Treg", "Treg17", "Th1", "Div_Th1", "Th17",
"Div_Th17", "CD8", "Act_CD8", "Div_Act_CD8", "IFNy_CD4", "IFNy_CD8",
"Treg_prop", "IL17A_CD4", "batch")
IFNy_faeces <- c("IFNy_FEC", "Caecum")
Gene.Exp.cols   <- c("IFNy", "IL.12", "IRG6", "CXCR3", "IL.6", "GBP2",
"IL.10", "IL.13", "IL.10", "IL.13", "IL1RN",
"CXCR3", "CASP1", "CXCL9",
"IDO1", "IRGM1", "MPO", "MUC2", "MUC5AC", "MYD88",
"NCR1", "PRF1", "RETNLB", "SOCS1", "TICAM1", "TNF")
#reading the overview table. In each row there is a link to the raw data for each experiment
OV <- read.csv("https://raw.githubusercontent.com/derele/Eimeria_Lab/master/Eimeria_Lab_overview.csv")
## ## Only the challenge experiments
#a list of the names of each experiments
# you can use it later, to select the experiments from ov
ChallengeEx  <- c("E57", "E10", "E11", "P4", "P3")
## ## download and append the weigth tables
#lapply: applies a function to every element of the list
#we select the challenge experimetns and the weight columns
#we apply to every element of the list the function read.csv
W <- lapply(OV[OV$Experiment%in%ChallengeEx, "weight"], read.csv)
#reduce: works on 1st and 2nd element, produces result and then uses the result
#with the 3rd element and so on
#we apply in this case the function rbind
Weight <- Reduce(rbind, W)
rm(W)
## ## Same for shedding
O <- lapply(OV[OV$Experiment%in%ChallengeEx, "shedding"], read.csv)
Oocysts <- Reduce(rbind, O)
rm(O)
## ## some don't agree
table(Oocysts$labels%in%Weight$labels)
table(Weight$labels%in%Oocysts$labels)
## there are more in in the weights table which are not found in the
## oocysts though
Weight[!Weight$labels%in%Oocysts$labels, ]
## But if the weight is NA the mouse was dead
table(Weight[!Weight$labels%in%Oocysts$labels &
is.na(Weight$weight), "dpi"])
### confirmed by the late dpi of these!
Results <- merge(Weight, Oocysts, all=TRUE)
## IDs sometimes with "_" sometimes without
Results$EH_ID <- gsub("LM_", "LM", Results$EH_ID)
## For now we hav to exclude those E11aBMI which have no mouse IDs
Results <- Results[!is.na(Results$EH_ID), ]
## Same for design
D <- lapply(OV[OV$Experiment%in%ChallengeEx, "design"], read.csv)
Des.cols <- Reduce(intersect, lapply(D, colnames))
Design <- Reduce(rbind, lapply(D, "[", Des.cols))
rm(D)
View(Design)
## Same for design
D <- lapply(OV[OV$Experiment%in%ChallengeEx, "design"], read.csv)
View(D)
D
setwd("~/GitHub/Eimeria_mouse_immunity/")
getwd()
