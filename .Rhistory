knitr::opts_chunk$set(echo = TRUE)
#install.packages("optimx", version = "2021-10.12") # this package is required for
#the parasite load package to work
library(tidyverse)
library(tidyr)
library(dplyr)
library(cowplot)
library(randomForest)
library(ggplot2)
library(caret)
library(ggpubr)
library(rfUtilities) # Implements a permutation test cross-validation for
# Random Forests models
#import data
hm <- read.csv("output_data/imputed_mice.csv")
setwd("~/GitHub/Eimeria_mouse_immunity/")
knitr::opts_chunk$set(echo = TRUE)
#install.packages("optimx", version = "2021-10.12") # this package is required for
#the parasite load package to work
library(tidyverse)
library(tidyr)
library(dplyr)
library(cowplot)
library(randomForest)
library(ggplot2)
library(caret)
library(ggpubr)
library(rfUtilities) # Implements a permutation test cross-validation for
# Random Forests models
#import data
hm <- read.csv("output_data/imputed_mice.csv")
Gene_lab   <- c("IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF") #"IL.12", "IRG6")
Genes_wild   <- c("IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF") #, "IL.12", "IRG6")
Facs_lab <- c("Position", "CD4", "Treg", "Div_Treg", "Treg17", "Th1",
"Div_Th1", "Th17", "Div_Th17", "CD8", "Act_CD8",
"Div_Act_CD8", "IFNy_CD4", "IFNy_CD8","Treg_prop",
"IL17A_CD4")
Facs_wild <- c( "Treg", "CD4", "Treg17", "Th1", "Th17", "CD8",
"Act_CD8", "IFNy_CD4", "IL17A_CD4", "IFNy_CD8")
# we need to change the  in challenge infections to a factor
hm$Parasite_challenge <- as.factor(hm$Parasite_challenge)
hm$MC.Eimeria <- as.factor(hm$MC.Eimeria)
# Here I create a new column, where we get the actual infection status
# According to the melting curve for eimeria
hm <- hm %>%
dplyr::mutate(current_infection = case_when(
Parasite_challenge == "E_ferrisi" & MC.Eimeria == "TRUE" ~ "E_ferrisi",
Parasite_challenge == "E_ferrisi" & MC.Eimeria == "FALSE" ~ "uninfected",
Parasite_challenge == "E_falciformis" & MC.Eimeria == "TRUE" ~ "E_falciformis",
Parasite_challenge == "E_falciformis" & MC.Eimeria == "FALSE" ~ "uninfected",
Parasite_challenge == "uninfected" & MC.Eimeria == "TRUE" ~ "infected_eimeria",
Parasite_challenge == "uninfected" & MC.Eimeria == "FALSE" ~ "uninfected",
TRUE ~ ""
))
# prepare the lab data
lab <- hm %>%
dplyr::filter(origin == "Lab")
#select the imputed gene columns
gene <-  lab %>%
dplyr::select(c(Mouse_ID, all_of(Gene_lab)))
gene <- unique(gene)
genes <- gene %>%
dplyr::select(-Mouse_ID)
#remove rows with only nas
genes <- genes[,colSums(is.na(genes))<nrow(genes)]
#remove colums with only nas
genes <- genes[rowSums(is.na(genes)) != ncol(genes), ]
# select the same rows from the gene data
gene <- gene[row.names(genes),]
# select the same rows from the lab data
lab <- lab[row.names(genes),]
gene <- lab %>%
dplyr::select(c(Mouse_ID, WL_max)) %>%
right_join(gene, by = "Mouse_ID")
gene <- unique(gene) %>%
dplyr::select(-Mouse_ID)
repeat_cv <- trainControl(method = "repeatedcv", #repeated cross validation
number = 5, # 5 fold cross validation
repeats = 3)
# split data into training and test
set.seed(333) # this will help us reproduce this random assignment
# in this way we can pick the random numbers
training.samples <- createDataPartition(y = gene$WL_max, p = .7, list = FALSE)
# this is the partiicition! In this case 0.7 = training data and 0.3 = testing
# we don't want to get a list in return
train.data <- gene[training.samples, ]
test.data <- gene[-training.samples, ]
set.seed(333)
#train the model
WL_predict_gene <- randomForest(WL_max ~., data = train.data,
proximity = TRUE, ntree = 1000)
# ntree = number of trees
# save the model
save(WL_predict_gene, file =  "r_scripts/models/WL_predict_gene.RData")
print(WL_predict_gene)
predict_WL_cv <- rf.crossValidation(x = WL_predict_gene, xdata = train.data,
p = 0.10, n = 99, ntree = 501)
predict_WL_cv$fit.var.exp
par(mfrow=c(2,2))
plot(predict_WL_cv)
# Root Mean Squared Error (observed vs. predicted) from each Bootstrap
# iteration (cross-validation)
plot(predict_WL_cv, stat = "mse")
#Percent variance explained from specified fit model
plot(predict_WL_cv, stat = "var.exp")
#Mean Absolute Error from each Bootstrapped model
plot(predict_WL_cv, stat = "mae")
plot(WL_predict_gene)
# number of trees with lowest MSE
which.min(WL_predict_gene$mse)
# RMSE of this optimal random forest
sqrt(WL_predict_gene$mse[which.min(WL_predict_gene$mse)])
### Visualize variable importance ----------------------------------------------
#Call importance() function on the model model to check how the attributes used
# as predictors affect our WL_predict_gene
importance(WL_predict_gene)
#WL_predict_gene$mse
## S3 method for class 'randomForest'
plot(WL_predict_gene, type = "l", main=deparse(substitute(x)))
varImpPlot(WL_predict_gene)
# Get variable importance from the WL_predict_gene fit
ImpData <- as.data.frame(importance(WL_predict_gene))
ImpData$Var.Names <- row.names(ImpData)
#The predict() function in R is used to predict the values based on the
# input data.
predictions <- predict(WL_predict_gene, test.data)
# assign test.data to a new object, so that we can make changes
result <- test.data
#add the new variable of predictions to the result object
result <- cbind(result, predictions)
# what is the correlation between predicted and actual data?
cor(result$WL_max, result$predictions,
method = c("pearson", "kendall", "spearman"))
test_lab <- lab %>%
left_join(result, by = c("WL_max", "IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF"))
test_lab <- test_lab %>%
drop_na(predictions)
# what is the correlation between predicted and actual data?
cor(result$WL_max, result$predictions,
method = c("pearson", "kendall", "spearman"))
test_lab   %>%
ggplot(aes(x = predictions, y = WL_max, color = Parasite_challenge,
size = delta_ct_cewe_MminusE)) +
geom_smooth(method = lm, se = FALSE) +
labs(x = "Predictions: Maximum weight loss",
y = "Observed: Maximum weight loss") +
geom_point(aes(x = predictions, y = WL_max,
color = Parasite_challenge, size = delta_ct_cewe_MminusE)) +
labs(x = "Predictions: Maximum weight loss",
y = "Observed: Maximum weight loss") +
theme_bw()
cor(test_lab$predictions, test_lab$WL_max, method = "spearman")
test_lab   %>%
ggplot(aes(x = predictions, y = WL_max,
size = delta_ct_cewe_MminusE)) +
geom_smooth(method = lm, se = TRUE) +
labs(x = "Predictions: Maximum weight loss",
y = "Observed: Maximum weight loss") +
geom_point(aes(x = predictions, y = WL_max,  size = delta_ct_cewe_MminusE)) +
labs(x = "Predictions: Maximum weight loss",
y = "Observed: Maximum weight loss") +
theme_bw()
#train the model
WL_predict_gene <- randomForest(WL_max ~., data = gene,
proximity = TRUE, ntree = 1000)
# ntree = number of trees
# save the model
# toa = trained on all
saveRDS(WL_predict_gene, "r_scripts/models/predict_WL.rds")
print(WL_predict_gene)
lab$Parasite_challenge <- as.factor(lab$Parasite_challenge)
gene_curr <- lab %>%
dplyr::select(c(Mouse_ID, all_of(Gene_lab), Parasite_challenge))
gene <- gene_curr %>%
dplyr::select(-Mouse_ID)
# split data into training and test
set.seed(123) # this will help us reproduce this random assignment
# in this way we can pick the random numbers
training.samples <- gene$Parasite_challenge%>%
createDataPartition(p = .7, list = FALSE)
train.data_parasite <- gene[training.samples, ]
test.data_parasite <- gene[-training.samples, ]
#train the model
model_Parasite <- randomForest(Parasite_challenge ~.,
data = train.data_parasite, proximity = TRUE,
ntree = 1500) # number of trees
# save the model
save(model_Parasite, file =  "r_scripts/models/predict_infecting_parasite.RData")
print(model_Parasite)
model_Parasite_cv <- rf.crossValidation(x = model_Parasite, xdata =
train.data_parasite,
p = 0.10, n = 99, ntree = 501)
model_Parasite_cv$fit.var.exp
# Plot cross validation versus model producers accuracy
#The predict() function in R is used to predict the values based on the input
# data.
predictions_parasite <- predict(model_Parasite, test.data_parasite)
# assign test.data to a new object, so that we can make changes
result_parasite <- test.data_parasite
#add the new variable of predictions to the result object
result_parasite <- cbind(result_parasite, predictions_parasite)
#add the results to a data frame containing test data and the prediction
result_parasite <- cbind(lab[row.names(result_parasite), ], predictions_parasite)
conf_matrix_parasite <-
confusionMatrix(
result_parasite$predictions_parasite,
reference = result_parasite$Parasite_challenge)
print(conf_matrix_parasite)
conf_matrix_parasite$table
plt <- as.data.frame(conf_matrix_parasite$table)
plt$Prediction <- factor(plt$Prediction, levels=rev(levels(plt$Prediction)))
ggplot(plt, aes(x = Prediction, y =  Reference, fill= Freq)) +
geom_tile() + geom_text(aes(label=Freq)) +
scale_fill_gradient(low="white", high="darkturquoise") +
labs(x = "Predictions",y = "Reference")
test_lab   %>%
ggplot(aes(x = predictions, y = WL_max, color = current_infection,
size = delta_ct_cewe_MminusE)) +
geom_smooth(method = lm, se = FALSE) +
labs(x = "Predictions: Maximum weight loss",
y = "Observed: Maximum weight loss") +
geom_point(aes(x = predictions, y = WL_max,
color = Parasite_challenge, size = delta_ct_cewe_MminusE)) +
labs(x = "Predictions: Maximum weight loss",
y = "Observed: Maximum weight loss") +
theme_bw()
knitr::opts_chunk$set(echo = TRUE)
library(mice)
library(tidyr)
library(tidyverse)
library(VIM)
library(fitdistrplus)
library(fitur)
library(visdat)
hm <- read.csv("output_data/MICE.csv")
# Vectors for selecting genes
#Lab genes
# The measurements of IL.12 and IRG6 are done with an other assay and will
#ignore for now
Gene_lab   <- c("IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF") #"IL.12", "IRG6")
Genes_wild   <- c("IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF") #, "IL.12", "IRG6")
Facs_lab <- c("CD4", "Treg", "Div_Treg", "Treg17", "Th1",
"Div_Th1", "Th17", "Div_Th17", "CD8", "Act_CD8",
"Div_Act_CD8", "IFNy_CD4", "IFNy_CD8","Treg_prop",
"IL17A_CD4")
Facs_wild <- c( "Treg", "CD4", "Treg17", "Th1", "Th17", "CD8",
"Act_CD8", "IFNy_CD4", "IL17A_CD4", "IFNy_CD8")
field <- hm %>%
dplyr::filter(origin == "Field")
field <- unique(field)
genes_mouse_field <- field %>%
dplyr::select(c(Mouse_ID, all_of(Genes_wild)))
genes <- genes_mouse_field  %>%
dplyr::select(-Mouse_ID)
#remove rows with only nas
genes <- genes[,colSums(is.na(genes))<nrow(genes)]
#remove colums with only nas
genes <- genes[rowSums(is.na(genes)) != ncol(genes), ]
genes_mouse_field <- genes_mouse_field[row.names(genes), ]
##select same rows in the first table
field <- field[row.names(genes), ]
###############lab
#select the genes and lab muce
lab <- hm %>%
dplyr::filter(origin == "Lab", Position == "mLN") #selecting for mln to avoid
# duplicates
lab <- unique(lab)
gene_lab_mouse <- lab %>%
dplyr::select(c(Mouse_ID, all_of(Gene_lab)))
gene_lab_mouse <- unique(gene_lab_mouse)
genes_lab <- gene_lab_mouse[, -1]
#remove rows with only nas
genes_lab <- genes_lab[,colSums(is.na(genes_lab))<nrow(genes_lab)]
#remove colums with only nas
genes_lab <- genes_lab[rowSums(is.na(genes_lab)) != ncol(genes_lab), ]
genes_lab <- unique(genes_lab)
#select same rows in the first table
gene_lab_mouse <- gene_lab_mouse[row.names(genes_lab), ]
##select same rows in the first table
lab <- lab[row.names(genes_lab), ]
hm_genes <- rbind(gene_lab_mouse, genes_mouse_field)
hm_selection_g <- rbind(lab, field)
genes <- hm_genes %>%
dplyr::select(-Mouse_ID)
# looking at patterns of nas
#pattern_na <-as.data.frame(md.pattern(field_genes))
sapply(hm_genes, function(x) sum(is.na(x)))
#had to remove as they were disturbing the imputation: Worms_presence, MC.Eimeria.FEC,  Heligmosomoides_polygurus, Zfy2, Y,  MpiC,
#vis_miss(field)
# The frequency distribution of the missing cases per variable can be obtained
# as:
init <- mice(genes, maxit = 0)
#we want to impute only the specific variables
meth <- init$method
aggr_plot <- aggr(hm_genes, col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, labels=names(hm_genes), cex.axis=.7, gap=3, ylab=c("Histogram of missing data","Pattern"))
# m=5 refers to the number of imputed datasets. Five is the default value.
igf <- mice(genes, m = 5, seed = 500) # method = meth,
summary(igf)
# to check each column with imputed data
## igf$imp$IFNy
#Now we can get back the completed dataset using the complete()
complete_genes <- complete(igf, 1)
#sapply(complete_field, function(x) sum(is.na(x)))
#visualize missingness
vis_dat(complete_genes)
#remove the non imputed genes from our data set
hm_selection_g <- hm_selection_g %>%
dplyr::select(-c("IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF"))
# add the new imputed genes to the data
hm_selection_g <- cbind(hm_selection_g, complete_genes)
xyplot(igf, IFNy ~ IL.13 + IRGM1 + MUC2, pch=18,cex=1)
xyplot(igf,IFNy ~ IL.10 + PRF1 + CASP1, pch=18,cex=1)
stripplot(igf, pch = 20, cex = 1.2)
densityplot(igf)
###############lab
#select the facs and lab muce
lab <- hm %>%
dplyr::filter(origin == "Lab", Position == "mLN") #selecting for mln to avoid
# duplicates
lab <- unique(lab)
facs_mouse <- lab %>%
dplyr::select(c(Mouse_ID, all_of(Facs_lab))) #choosing the same with the wild
facs_mouse <- unique(facs_mouse)
facs_lab <- facs_mouse[, -1]
#remove rows with only nas
facs_lab <- facs_lab[,colSums(is.na(facs_lab))<nrow(facs_lab)]
#remove colums with only nas
facs_lab <- facs_lab[rowSums(is.na(facs_lab)) != ncol(facs_lab), ]
#select same rows in the first table
facs_mouse <- facs_mouse[row.names(facs_lab), ]
##select same rows in the first table
lab <- lab[row.names(facs_mouse), ]
#########################Field
###########field
# somehow the field samples have the origin na,
# fix that
field <- hm %>%
dplyr::filter(origin == "Field")
field <- unique(field)
facs_mouse <- field %>%
dplyr::select(c(Mouse_ID, all_of(Facs_wild)))
facs_field <- facs_mouse[,-1]
#remove rows with only nas
facs_field <- facs_field[,colSums(is.na(facs_field))<nrow(facs_field)]
#remove colums with only nas
facs_field <- facs_field[rowSums(is.na(facs_field)) != ncol(facs_field), ]
##select same rows in the first table
field <- field[row.names(facs_field), ]
facs_data <- full_join(lab, field, by = intersect(colnames(lab), colnames(field)))
facs_data <- unique(facs_data) %>%
dplyr::select(-c("IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF"))
hm_selection_g <- hm_selection_g %>%
full_join(facs_data, by = intersect(colnames(facs_data), colnames(hm_selection_g)))
hm_selection_g <- unique(hm_selection_g)
##save the imputed data
write.csv(hm_selection_g, "output_data/imputed_mice.csv", row.names = FALSE)
plot(igf)
aggr_plot <- aggr(hm_genes, col=c('navyblue','red'), numbers=TRUE, sortVars=TRUE, labels=names(hm_genes), cex.axis=.7, gap=3, ylab=c("Histogram of missing data","Pattern"))
marginplot(hm_genes[c(1,2)])
marginplot(hm_genes[c(2,3)])
marginplot(hm_genes[c(3,4)])
marginplot(hm_genes[c(4,5)])
knitr::opts_chunk$set(echo = TRUE)
#install.packages("optimx", version = "2021-10.12") # this package is required for
#the parasite load package to work
library(tidyverse)
library(tidyr)
library(dplyr)
library(cowplot)
library(randomForest)
library(ggplot2)
library(VIM) # visualizing missing data
library(mice) # imputing missing data without predictors
library(ggpubr)
library(optimx)
library(rfUtilities) # Implements a permutation test cross-validation for
# Random Forests models
library(mice) #imputations
library(fitdistrplus) #testing distributions
library(logspline)
library(caret)
hm <- read.csv("output_data/imputed_mice.csv")
Field <- hm %>%
filter(origin == "Field") %>%
drop_na(HI)
EqPCR.cols      <- c("delta_ct_cewe_MminusE", "MC.Eimeria", "Ct.Eimeria") #,"Ct.Mus""delta_ct_ilwe_MminusE", )
Genes_wild   <- c("IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF") #, "IL.12", "IRG6")
#select the imputed gene columns
gene <-  Field %>%
dplyr::select(c(Mouse_ID, "IFNy", "CXCR3", "IL.6", "IL.13", "IL.10",
"IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO",
"MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1",
"TICAM1", "TNF"))
genes <- gene %>%
dplyr::select(-Mouse_ID)
#remove rows with only nas
genes <- genes[,colSums(is.na(genes))<nrow(genes)]
#remove colums with only nas
genes <- genes[rowSums(is.na(genes)) != ncol(genes), ]
# select the same rows from the gene data
gene <- gene[row.names(genes),]
# select the same rows from the field data
Field <- Field[row.names(genes),]
# load predicting weight loss model
weight_loss_predict <- readRDS("r_scripts/models/predict_WL.rds")
set.seed(540)
#The predict() function in R is used to predict the values based on the input data.
predictions_field <- predict(weight_loss_predict, genes)
#make the vector positive so that the distributions further down work
predictions_field <- predictions_field * (-1)
# assign test.data to a new object, so that we can make changes
result_field <- genes
#add the new variable of predictions to the result object
result_field <- cbind(result_field, predictions_field)
# add it to the field data
Field <- cbind(Field, predictions_field)
require(devtools)
devtools::install_github("alicebalard/parasiteLoad@v2.0", force = TRUE)
