---
title: "5. PCA genes - Lab"
author: "Fay"
date: '2022-10-08'
output:
  pdf_document:
    keep_md: yes 
    fig_width: 12
    fig_height: 8
  html_document:
    df_print: paged
---

Always change the knitting directory to the working directory!
# Load libraries

```{r message = FALSE, warnings = FALSE}
library(tidyverse)
library(dplyr)
library(stringr)
library(FactoMineR)
library(reshape2)
library(corrplot)
library(factoextra)
library(lmtest)
library(ggpubr)
library(janitor)
library(pheatmap)
library(visdat)
```


# Load data

I am using a normalized and imputed data set.

```{r}
hm <- read.csv("output_data/2.imputed_MICE_data_set.csv")
```


# vectors for selecting

```{r}
Gene_lab   <- c("IFNy", "CXCR3", "IL.6", "IL.13",
                "IL1RN","CASP1", "CXCL9", "IDO1", "IRGM1", "MPO", 
                "MUC2", "MUC5AC", "MYD88", "NCR1", "PRF1", "RETNLB", "SOCS1", 
                "TICAM1", "TNF") # "IL.12", "IRG6")

```

# PCA on the lab genes
Firts I am preparing and cleaning the data before initiating the PCA.
```{r black_and_white_pca}
#select the genes and lab muce
lab <- hm %>%
  dplyr::filter(origin == "Lab", Position == "mLN") #selecting for mln to avoid
# duplicates

lab <- unique(lab)

gene <- lab %>%
  dplyr::select(c(Mouse_ID, all_of(Gene_lab)))

genes <- unique(gene)

genes <- genes[, -1]

#remove rows with only nas
genes <- genes[,colSums(is.na(genes))<nrow(genes)]

#remove colums with only nas 
genes <- genes[rowSums(is.na(genes)) != ncol(genes), ]

#select same rows in the first table
gene <- gene[row.names(genes), ]

# we can now run a normal pca on the complete data set
res.pca <- PCA(genes)
```
How much does each dimension contribute to variabce?

```{r percentage_of_explained_variance_per_dimension}
fviz_eig(res.pca, addlabels = TRUE, ylim = c(0, 70))
```
"Principal Component Analysis of Immune Gene 
             Expression in Laboratory-Controlled Eimeria Infections"
             
Part of the first figure in the publication in colour blind friendly colours.
 width = 10, height = 6, units = "cm", res = 1000
```{r PCA_gene_lab_fig_1, dpi = 500 }
fviz_pca_var(res.pca, col.var = "cos2",
             gradient.cols = c("#DB6212", "#CC8733", "#5f25e6", "#073DA8"),
             repel = TRUE, title = "")
```
```{r 2, dpi = 200 }
fviz_pca_var(res.pca, col.var = "cos2",
             gradient.cols = c("#DB6212", "#CC8733", "#5f25e6", "#073DA8"),
             repel = TRUE, title = "")
```
```{r 3,  res = 1000}
fviz_pca_var(res.pca, col.var = "cos2",
             gradient.cols = c("#DB6212", "#CC8733", "#5f25e6", "#073DA8"),
             repel = TRUE, title = "")
```

```{r individual_plot_pca }
fviz_pca_ind(res.pca, col.ind = "cos2", 
                  gradient.cols = c("#DB6212", "#CC8733", "#5f25e6", "#073DA8"), 
                  repel = TRUE)
```


```{r dimensions, include = FALSE, echo = FALSE, warnings = FALSE}
#Description of the dimensions
# We get a correlation between each variable and the first dimension
dimdesc(res.pca)
```

Caution: When imputing data, the percentages of inertia associated with the first dimensions will be overestimated.

Another problem: the imputed data are, when the pca is performed considered like real observations.
But they are estimations!! 

Visualizing uncertainty due to issing data:

--> mulrimple imputation: generate several plausible values for each missing data point

We here visualize the variability, that is uncertainty on the plane defined by two pca axes. 

```{r, echo = FALSE, include = FALSE}
str(res.pca)
```



```{r, echo = FALSE}

 #add an ending to the imputed columns
#colnames(gene) <- paste(colnames(gene[, 2:21]), "imp", sep = "_")

mouse_id <- gene %>%
  dplyr::select(Mouse_ID)



mouse_id$pc1 <- res.pca$ind$coord[, 1] # indexing the first column

mouse_id$pc2 <- res.pca$ind$coord[, 2]  # indexing the second column




lab <- lab %>% 
  left_join(mouse_id, by = "Mouse_ID")



#We also need to extract the data for the variable contributions to each of the pc axes.
pca.vars <- res.pca$var$coord %>% data.frame


pca.vars$vars <- rownames(pca.vars)

pca.vars.m <- melt(pca.vars, id.vars = "vars")

source("r_scripts/functions/circle_fun.R")

circ <- circleFun(c(0,0),2,npoints = 500)

```


Biplot of the imputed gene pca


```{r biplot_pca_genes}

#Now we can make our initial plot of the PCA.
lab %>%
  ggplot(aes(x = pc1, y = pc2, 
             color = Parasite_challenge, 
             shape = Parasite_challenge)) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
  geom_point(alpha = 0.8) +
  stat_ellipse(geom="polygon", 
               aes(fill = challenge_infection), 
               alpha = 0.2, show.legend = FALSE,
               level = 0.95) +
  theme_minimal() +
  theme(panel.grid = element_blank(), 
        panel.border = element_rect(fill= "transparent")) 
  
```


```{r correlations_genes_dimensions, echo = FALSE}
#It’s possible to use the function corrplot() [corrplot package] to highlight 
#the most contributing variables for each dimension:
var.contrib <- res.pca$var$contrib
corrplot(var.contrib, is.corr=FALSE) 
```

The function fviz_contrib() [factoextra package] can be used to draw a bar plot of variable contributions. If your data contains many variables, you can decide to show only the top contributing variables. The R code below shows the top 10 variables contributing to the principal components:


```{r contr_var_pc_genes, echo = FALSE}
# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 18)

```

The genes CASP1, CXCR3, MUC2, and IRGM1 are involved in various immune responses and have different roles:

CASP1 (Caspase 1): It plays a crucial role in the innate immune response by activating pro-inflammatory cytokines IL-1beta and IL-18. CASP1 is involved in initiating pyroptosis, a form of programmed cell death, and is associated with inflammatory conditions.

CXCR3 (C-X-C motif chemokine receptor 3): It is a chemokine receptor expressed on immune cells, including T cells and natural killer cells. CXCR3 is involved in the recruitment of immune cells to sites of inflammation and plays a role in immune responses against pathogens and tumors.

MUC2 (Mucin 2): It is a major component of the mucus layer that lines various epithelial surfaces, including the intestinal tract. MUC2 provides a physical barrier and helps protect against pathogens and other harmful substances.

IRGM1 (Immunity-Related GTPase Family M Member 1): It is an immunity-related GTPase involved in host defense against intracellular pathogens. IRGM1 participates in autophagy, a cellular process that eliminates intracellular pathogens and helps regulate immune responses.

The common thread connecting these genes and immune responses is their involvement in the innate immune system. The innate immune system provides immediate defense against pathogens and triggers an inflammatory response. These genes and their respective proteins contribute to the recognition of pathogens, recruitment of immune cells, activation of cytokines, and protection of epithelial surfaces.

Regarding damaging processes to the host, excessive or dysregulated activation of immune responses can lead to tissue damage and inflammation. Inflammatory conditions associated with uncontrolled immune responses can have detrimental effects on the host. For example, chronic inflammation can contribute to tissue destruction, organ damage, and autoimmune diseases. Balancing the immune response is essential to prevent excessive damage while effectively combating pathogens or maintaining tissue homeostasis.

```{r}
# Contributions of variables to PC2
fviz_contrib(res.pca, choice = "var", axes = 2, top = 18)
```

In the context of intestinal parasites, the involvement of IDO1, TICAM1, SOCS1, and Interleukin 13 (IL-13) can vary depending on the specific parasite and the host immune response. Here is some information regarding their roles in the context of intestinal parasites:

IDO1 (Indoleamine 2,3-dioxygenase 1): IDO1 is an enzyme involved in the metabolism of tryptophan, an essential amino acid. In the context of intestinal parasites, IDO1 expression can be induced as part of the host immune response to control parasite infections. IDO1 can modulate immune responses by degrading tryptophan, leading to the inhibition of parasite growth and the generation of immunoregulatory metabolites.

TICAM1 (Toll-like receptor adaptor molecule 1): TICAM1 is an adaptor protein involved in Toll-like receptor (TLR) signaling pathways. TLRs play a crucial role in recognizing microbial components and initiating immune responses. In the context of intestinal parasites, TICAM1 may be involved in the activation of TLR signaling pathways in response to parasite-derived molecules, leading to the production of pro-inflammatory cytokines and the initiation of an immune response.

SOCS1 (Suppressor of Cytokine Signaling 1): SOCS1 is a negative regulator of cytokine signaling. It helps control the duration and intensity of cytokine signaling by inhibiting downstream signaling pathways. In the context of intestinal parasites, SOCS1 may be induced as part of a negative feedback mechanism to prevent excessive immune activation and inflammation caused by the host response to the parasite. It can inhibit cytokine signaling pathways, including those involving IL-13, to regulate the immune response.

Interleukin 13 (IL-13): IL-13 is an immunoregulatory cytokine that plays a role in mediating the host immune response to intestinal parasites. IL-13 can be produced by immune cells, such as T cells and innate lymphoid cells, in response to parasite infection. It can contribute to the activation of immune cells, promote the recruitment of inflammatory cells to the site of infection, and induce the production of mucus and other factors that can help expel parasites from the intestine.

It's important to note that the specific roles and interactions of these factors can vary depending on the type of intestinal parasite, the host immune response, and the specific mechanisms of immune evasion employed by the parasite.


The reactions involving IDO1, TICAM1, SOCS1, and Interleukin 13 (IL-13) in response to intestinal parasites can have both beneficial and potentially damaging effects on the host. The degree of damage depends on various factors, including the type and virulence of the parasite, the intensity and duration of the immune response, and the susceptibility of the host.

Beneficial Effects: These reactions are part of the host's immune defense against parasites and aim to control and eliminate the infection. The immune response triggered by these factors can help limit parasite growth, prevent parasite dissemination, and promote the clearance of the parasites from the intestinal tract. Additionally, the production of cytokines, such as IL-13, can stimulate the production of mucus and enhance the barrier function of the intestinal epithelium, aiding in the expulsion of parasites.

Potential Damaging Effects: In some cases, the immune response can be excessive or dysregulated, leading to tissue damage and inflammation. Chronic or uncontrolled immune responses can cause collateral damage to the host tissues and disrupt normal physiological processes in the intestine. Excessive production of pro-inflammatory cytokines and chemokines can contribute to tissue damage, inflammation, and alteration of the gut microbiota. Additionally, prolonged activation of immune signaling pathways, such as those involving TICAM1 and SOCS1, can lead to immune system dysfunction and contribute to chronic inflammation.

It's important to note that the balance between the beneficial and damaging effects of the immune response is crucial. In an effective immune response, the host can effectively control and eliminate the parasites while minimizing damage to its own tissues. However, in some cases, the immune response can be insufficient, allowing the parasites to persist and cause chronic infections or tissue damage. The overall impact on the host depends on the interplay between the host immune response, the parasite's virulence factors, and the host's genetic and environmental factors.

```{r contr_var_pc1_2_genes, echo = FALSE}
fviz_contrib(res.pca, choice = "var", axes = 1:2, top = 18)
```
The red dashed line on the graph above indicates the expected average contribution. If the contribution of the variables were uniform, the expected value would be 1/length(variables) = 1/10 = 10%. For a given component, a variable with a contribution larger than this cutoff could be considered as important in contributing to the component.

Note that, the total contribution of a given variable, on explaining the variations retained by two principal components, say PC1 and PC2, is calculated as contrib = [(C1 * Eig1) + (C2 * Eig2)]/(Eig1 + Eig2), where

C1 and C2 are the contributions of the variable on PC1 and PC2, respectively
Eig1 and Eig2 are the eigenvalues of PC1 and PC2, respectively. Recall that eigenvalues measure the amount of variation retained by each PC.
In this case, the expected average contribution (cutoff) is calculated as follow: As mentioned above, if the contributions of the 10 variables were uniform, the expected average contribution on a given PC would be 1/10 = 10%. The expected average contribution of a variable for PC1 and PC2 is : [(10* Eig1) + (10 * Eig2)]/(Eig1 + Eig2)



```{r pca_contribution_genes, echo = FALSE}

#The most important (or, contributing) variables can be highlighted on the 
#correlation plot as follow:
fviz_pca_var(res.pca, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
             )
```



To visualize the contribution of individuals to the first two principal components:

```{r contr_individuals_genes, echo = FALSE}
# Total contribution on PC1 and PC2
fviz_contrib(res.pca, choice = "ind", axes = 1:2)
```

PCA + Biplot combination

```{r pca_biplot_genes, echo = FALSE}
#select same rows in the first table
lab <- lab[row.names(genes), ]

fviz_pca_biplot(res.pca, 
                col.ind = lab$Parasite_challenge, palette = "jco", 
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Parasite in the challenge infection") 

```
 In the following example, we want to color both individuals and variables by groups. The trick is to use pointshape = 21 for individual points. This particular point shape can be filled by a color using the argument fill.ind. The border line color of individual points is set to “black” using col.ind. To color variable by groups, the argument col.var will be used.





################## Linear models: 

```{r , echo = FALSE}


weight_lm <- lm(WL_max ~ pc1 + pc2, data = lab)
summary(weight_lm)
AIC(weight_lm)
```

```{r lm_weight_pc, echo = FALSE}
#lab <- lab %>%
 # mutate(WL_max = WL_max)

weight_lm <- lm(WL_max ~ pc1 + pc2 + hybrid_status, data = lab)
summary(weight_lm)
AIC(weight_lm)
```




```{r lm_pc_parasite_hybrid, echo = FALSE}

weight_lm2 <- lm(WL_max ~ pc1 + pc2 + Parasite_challenge + hybrid_status, 
                 data = lab)
summary(weight_lm2)
AIC(weight_lm2)
```


Try instead: 
LLR test (likelihood ration)  (LM4 package )? 

https://www.rdocumentation.org/packages/lmtest/versions/0.9-38/topics/lrtest

In this way you compare each model, with the different variables usesd to predict. 

Another way is to compare the AIC. (function : step)

```{r}


weight_lm3 <- lm(WL_max ~ pc1 + pc2 + hybrid_status, data = lab)
weight_no_pc1 <- lm(WL_max ~ pc2 + hybrid_status, data = lab)
weight_no_pc2 <- lm(WL_max ~ pc1  + hybrid_status, data = lab)
weight_no_hybrid <- lm(WL_max ~ pc1 + pc2, data = lab)
lrtest(weight_lm3, weight_no_pc1)
lrtest(weight_lm3, weight_no_pc2)
lrtest(weight_no_pc1, weight_no_pc2)
lrtest(weight_lm3, weight_no_hybrid)
```


```{r lm_pc_hybrid, echo = FALSE}
weight_lm3 <- lm(WL_max ~ pc1 + pc2 + hybrid_status, data = lab)
summary(weight_lm3)
AIC(weight_lm3)
```



```{r lm_inf_histoy, echo=FALSE}
weight_lm4 <- lm(WL_max ~ pc1 + pc2 + infection_history, data = lab)
summary(weight_lm4)
AIC(weight_lm4)

```


```{r lm_pc, echo = FALSE}
weight_lm_exp_only <- lm(WL_max ~ pc1 + pc2, data = lab)
summary(weight_lm_exp_only)
AIC(weight_lm, weight_lm_exp_only)
```

### repeating the heatmap on the now imputed data
```{r}
 # turn the data frame into a matrix and transpose it. We want to have each cell 
 # type as a row name 
 gene <- t(as.matrix(gene))
 
 # turn the first row into column names
 gene %>%
     row_to_names(row_number = 1) -> heatmap_data
 
 heatmap_data <- as.data.frame(heatmap_data)
 
 table(rowSums(is.na(heatmap_data)) == nrow(heatmap_data))

 
# turn the columns to numeric other wise the heatmap function will not work
 heatmap_data[] <- lapply(heatmap_data, function(x) as.numeric(as.character(x)))

 # remove columns with only NAs 
 heatmap_data <- Filter(function(x)!all(is.na(x)), heatmap_data) 
 
 #remove rows with only Nas
 heatmap_data <-  heatmap_data[, colSums(is.na(heatmap_data)) != 
                                   nrow(heatmap_data)]
 
  
#Prepare the annotation data frame
annotation_df <- as_tibble(lab) %>%
    dplyr::select(c("Mouse_ID",  "WL_max", "Parasite_challenge")) 
  
annotation_df <- unique(annotation_df) 

annotation_df <- as.data.frame(annotation_df)




### Prepare the annotation columns for the heatmap
rownames(annotation_df) <- annotation_df$Mouse_ID


# Match the row names to the heatmap data frame
rownames(annotation_df) <- colnames(heatmap_data)

#remove the unecessary column
annotation_df <- annotation_df %>% dplyr::select(-Mouse_ID, )


```


Heatmap on gene expression data: 


```{r, echo = FALSE}
pheatmap(heatmap_data, annotation_col = annotation_df,  scale = "row",  clustering_distance_rows = "euclidean", clustering_distance_cols = "euclidean")
```