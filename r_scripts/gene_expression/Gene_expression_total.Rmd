---
title: "Gene_expression"
author: "Fay"
date: "09/05/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Gene expression - laboratory infections

```{r echo=FALSE}
library(pheatmap)
library(tidyverse)
library(matrixStats)
library(tidyr)
library(janitor)
library(tibble)
library(corrplot)
library(RColorBrewer)
library(ggplot2)
library(dplyr)

```


```{r pressure, echo=FALSE, include = FALSE}
### Import the data
Challenge <- read.csv("https://raw.githubusercontent.com/derele/Eimeria_Lab/master/data_products/Challenge_infections.csv")

Genes <- c("IFNy", "CXCR3_bio", "IL.6", "IFNy",
  "IL.10", "IL.13", "IL.10", "IL.13", "IL1RN", "CASP1", "CXCL9", 
  "IDO1", "IRGM1", "MPO", "MUC2", "MUC5AC", "MYD88", 
  "NCR1", "PRF1", "RETNLB", "SOCS1", "TICAM1", "TNF")

basics_gene <- as_tibble(Challenge) %>%
  dplyr::filter(infection == "challenge", dpi == "8") %>%
  dplyr::group_by(EH_ID, infection) %>%
  dplyr::select(c("EH_ID", "primary_infection", "challenge_infection", "infection_history",
           "mouse_strain", "max_WL", Genes, "delta"))

Challenge <- Challenge %>%
    dplyr::mutate(Parasite_primary = case_when(
        primary_infection == "E64" ~ "Eimeria ferrisi",
        primary_infection == "E88" ~ "Eimeria falciformis",
        primary_infection == "Eflab" ~ "Eimeria falciformis",
        primary_infection == "E139" ~ "Eimeria ferrisi",
        primary_infection == "UNI" ~ "uninfected",
        TRUE ~ ""))


Challenge <- Challenge %>%
    dplyr::mutate(Parasite_challenge = case_when(    
        challenge_infection == "E64" ~ "Eimeria ferrisi",
        challenge_infection == "E88" ~ "Eimeria falciformis",
        challenge_infection == "Eflab" ~ "E. falciformis",
        challenge_infection == "E139" ~ "Eimeria ferrisi",
        challenge_infection == "UNI" ~ "uninfected",
        TRUE ~ ""))

# remove duplicated and change the format to data frame 
basics_gene <- unique(basics_gene) %>%
  as.data.frame(basics_gene) %>%
  dplyr::select(-infection)
 
gene <- basics_gene %>% dplyr::select(c(EH_ID, Genes))

 
 # turn the data frame into a matrix and transpose it. We want to have each cell 
 # type as a row name 
 gene <- t(as.matrix(gene))
 
 #switch the matrix back to a data frame format
 gene <- as.data.frame(gene)
 
 # turn the first row into column names
 gene %>%
     row_to_names(row_number = 1) -> gene
 
 # Now further prepare the data frame for plotting by removing the first row
 ## and convert the column to row names with the cells 
 gene[-1, ] -> heatmap_data
 
 
 table(rowSums(is.na(heatmap_data)) == nrow(heatmap_data))

 
 # turn the columns to numeric other wise the heatmap function will not work
 heatmap_data[] <- lapply(heatmap_data, function(x) as.numeric(as.character(x)))

 # remove columns with only NAs 
 heatmap_data <- Filter(function(x)!all(is.na(x)), heatmap_data) 
 
 #remove rows with only Nas
 heatmap_data <-  heatmap_data[, colSums(is.na(heatmap_data)) != nrow(heatmap_data)]

 rowSums(is.na(heatmap_data))
 

 
### Prepare the annotation data frame for the heatmap
 
## First select the common mice between your two data frames
 #now we have different row names in the two data frames because I removed the Nas
 #join the heatmap data to the basic data frame and get only the common columns
 gene_expr <- basics_gene %>% 
   dplyr::select(c(EH_ID, primary_infection, challenge_infection, infection_history, mouse_strain, 
            max_WL, delta)) %>%
     inner_join((t(heatmap_data) %>% 
                   as.data.frame() 
                 %>% tibble::rownames_to_column("EH_ID")), 
                by = "EH_ID")
 
 gene_expr <- gene_expr %>%
     dplyr::mutate(Parasite_challenge = case_when(    
         challenge_infection == "E64" ~ "Eimeria ferrisi",
         challenge_infection == "E88" ~ "Eimeria falciformis",
         challenge_infection == "Eflab" ~ "E. falciformis",
         challenge_infection == "E139" ~ "Eimeria ferrisi",
         challenge_infection == "UNI" ~ "uninfected",
         TRUE ~ ""))
 
annotation_df <- gene_expr %>%
  dplyr::select(c("EH_ID", "Parasite_challenge", "infection_history", "max_WL"))


annotation_df <- as.data.frame(annotation_df)

### Prepare the annotation columns for the heatmap
rownames(annotation_df) <- annotation_df$EH_ID


# Match the row names to the heatmap data frame
rownames(annotation_df) <- colnames(heatmap_data)

#remove the unecessary column
annotation_df <- annotation_df %>% dplyr::select(-EH_ID, )
```
Heatmap on gene expression data: 
```{r, echo = FALSE}
pheatmap(heatmap_data, annotation_col = annotation_df, scale = "row")
```
```{r, echo=FALSE, include=FALSE}
rm(heatmap_data, gene, annotation_df)
```

## Gene correlation
```{r, echo = FALSE}
# draw correlation between the genes
gene_correlation <- as.matrix(cor(Challenge %>% dplyr::select(Genes), use="pairwise.complete.obs"))


##Combining correlogram with the significance test
## Computing the p-value of correlations
## To compute the matrix of p-value, a custom R function is used 
# ... : further arguments to pass to the native R cor.test function
#tutorial: http://www.sthda.com/english/wiki/visualize-correlation-matrix-using-correlogram

# mat : is a matrix of data
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
    colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
    p.mat
}

# matrix of the p-value of the correlatio
p.mat <- cor.mtest(gene_correlation)
```

### Correlations between genes: 
```{r}
corrplot(gene_correlation, 
         method = "circle",  #method of the plot, "color" would show colour gradient
         tl.col = "black", tl.srt=45, #colour of labels and rotation
         col = brewer.pal(n = 8, name ="RdYlBu"), #colour of matrix
         order="hclust") #hclust reordering
```

### Correlations between genes, only including significant values
```{r, echo = FALSE}

corrplot(gene_correlation, 
         method = "circle",  #method of the plot, "color" would show colour gradien
         tl.col = "black", tl.srt=45, #colour of labels and rotation
         col = brewer.pal(n = 8, name ="RdYlBu"), #colour of matrix
         order="hclust", #hclust reordering
         p.mat = p.mat, sig.level = 0.01, insig = "blank") #Add significance level to the correlogram
        #remove the values that are insignificant
```
### Adding correlation coefficients
```{r, echo = FALSE}

corrplot(gene_correlation, 
         method = "number",  #method of the plot, "color" would show colour gradien
         tl.col = "black", tl.srt=45, #colour of labels and rotation
         col = brewer.pal(n = 8, name ="RdYlBu"), #colour of matrix
         order="hclust", #hclust reordering
         p.mat = p.mat, sig.level = 0.01, insig = "blank") #Add significance level to the correlogram
#remove the values that are insignificant

rm(p.mat, Genes)
```

```{r, echo = FALSE}
gene_expr %>%
    pivot_longer(cols = 8:26, names_to = "Gene", values_to = "gene_expression") %>%
    na.omit(delta) %>%
    ggplot(aes(x = delta, y = gene_expression, color = Parasite_challenge)) +
    geom_jitter() +
    facet_wrap(~ Gene, scales = "free") +
    theme_light() +
    labs(x = "Delta Ct, Infection intensity", y = "Gene expression",
         title = "Gene expression in response to infection intensity") +
    theme_bw()

```


```{r, echo = FALSE}
gene_expr %>%
    group_by(EH_ID) %>%
  pivot_longer(cols = 8:26, names_to = "Gene", values_to = "gene_expression") %>%
  na.omit(expression) %>%
  ggplot(aes(x = challenge_infection, y = gene_expression, color = challenge_infection)) + 
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~ Gene) +
  theme_bw() +
    labs(x = "Infection groups, E64 = E. ferrisi, E88 = E.falciformis, 
         UNI = Uninfected", y = "Gene expression",
         title = "Gene expression in response to infection group") 
```
```{r}
gene_expr %>%
    group_by(EH_ID) %>%
  pivot_longer(cols = 8:26, names_to = "Gene", values_to = "gene_expression") %>%
  ggplot(aes(x = gene_expression, color = challenge_infection)) + 
  geom_histogram()

gene_expr %>%
    group_by(EH_ID) %>%
  filter(!challenge_infection == "UNI") %>%
  pivot_longer(cols = 8:26, names_to = "Gene", values_to = "gene_expression") %>%
  ggplot(aes(x = gene_expression, color = challenge_infection)) + 
  geom_histogram()
```
```{r}
summary(gene_expr)
g <- gene_expr

```

It is possible to compute a pca with missing data using the package missMDA. 
The missMDA package is dedicated to missing values in exploratory  multivariate data analysis: single imputation/multiple imputation, etc. 

Following the tutorial of the package author: Francois Husson: https://www.youtube.com/watch?v=OOM8_FH6_8o

#### Handling missing data in a pca:
Bad methods: removing individuals with missing data or replacing missing data with the mean (default setting in many packages).

```{r}
library(missMDA) 
library(FactoMineR)


```

```{r, echo = FALSE}
#Make a scatter plot matrix showing the correlation coefficients between variables and the significance levels : the package PerformanceAnalytics is required.
library(PerformanceAnalytics)
chart.Correlation(g[8:26], histogram=TRUE, pch=19)
```


```{r}
## let's try a pca without imputing the missing values , 
# the function imputes the missing values by the mean of the variable to which 
# they belong
res.pca <- PCA(g[8:26])
```
```{r}
#let's do a pca while removing ALL NA values
res.NA.remove <- PCA(g[8:26] %>% na.omit())

# These are rather unsophisticated ways to solve the problem

```

We will now continue by using an iterative pca to impute missing data 
 A. Initialization: impute using the mean
 B. Step lampda:
  # a. do pca on imputed data table S dimensions retained
  # b. missing data imputed using pca
  # c. means (and standard deviations) updated
 C. Iterate the estimation and imputation steps (until convergence)
(convergence: the act of converging and especially moving toward union or uniformity)

Overfitting is a common problem due to believing too much in links between variables. 
--> regularized iterative PCA (This version is what is being implented in missMDA)
This is a way of taking less risk when imputing the missing data. 
The algorithm estimates the missing data values with values that have no influence
on the PCA results, i.e., no influence on the coordinates of the individals or variables. 

```{r}
## 1. Estimate the number of dimensions necessary to impute the dataset 
# with the estim_ncpPCA
nb <- estim_ncpPCA(g[8:26], scale = TRUE) 
# Each observed value is removed, then imputed using ncp components
# The difference between the ovserved value and the imputed value is calculated 
# ncp = 5

## 2. Imputation of the missing values using the function impute PCA
comp <- imputePCA(g[8:26], ncp = 5, scale = TRUE) #impute the table
head(comp$completeObs) # resulting imputed data table
# this estimate should be better than simply using the mean, beacause we've taken into account
# the links between variables and similarities between individuals in its calculation

options(ggrepel.max.overlaps = Inf) # solution to the error: 
# ggrepel: 3 unlabeled data points (too many overlaps). Consider increasing max.overlaps 
# for the next function

# we can now run a normal pca on the complete data set
res.pca <- PCA(comp$completeObs)
head(summary(res.pca, nbelements = Inf)) #including all the elements
```
```{r}
#Description of the dimensions
# We get a correlation between each variable and the first dimension
dimdesc(res.pca)
```


Caution: When imputing data, the percentages of inertia associated with the first dimensions will be overestimated.

Another problem: the imputed data are, when the pca is performed considered like real observations.
But they are estimations!! 

Visualizing uncertainty due to issing data:

--> mulrimple imputation: generate several plausible values for each missing data point

We here visualize the variability, that is uncertainty on the plane defined by two pca axes. 
```{r}
#Visualizing uncertainty due to missing data:

mi <- MIPCA(g[8:26], scale = TRUE, ncp = 5)
plot(mi)
```
Individuals lying on the axis have no missing data, but individuals that far away have many missing data. 
big ellipse = big uncertainty
tight elipse (line) = low uncertainty

Variable representation: 
Poins tight together )look like one) - have no missing variables --> low uncertainty
Points spread -- > higher variability -- > higher uncertainty


High uncertainty--> we should interpret the result with care

The individuals with many missing data values make the axes move, 
and thus the positions of all individuals

Therefore in the last plots every individual is getting an eclipse as they are as well influenced by the missing data of the others. 


THe plot with the dimensions shows the projections of the pca dimensions of each imputed table on the pca plane obtained using the original imputed data table

As all of the arrows are close to either the first or second axes, 
this means that the axes are stable with respect to the set of imputed tables --> we don't have evidence of instability here.

```{r, echo = FALSE, include = FALSE}
str(res.pca)
```

```{r}
library(factoextra)
library(MASS)
library(reshape2)
library(cowplot)
# extract pc scores for first two component and add to dat dataframe
g$pc1 <- res.pca$ind$coord[, 1] # indexing the first column

g$pc2 <- res.pca$ind$coord[, 2]  # indexing the second column

#We also need to extract the data for the variable contributions to each of the pc axes.
pca.vars <- res.pca$var$coord %>% data.frame
pca.vars$vars <- rownames(pca.vars)
pca.vars.m <- melt(pca.vars, id.vars = "vars")


#By convention, the variable contribution plot has a circle around the variables that has a radius of 1. Here’s some code to make one.
circleFun <- function(center = c(0,0),diameter = 1, npoints = 100){
  r = diameter / 2
  tt <- seq(0,2*pi,length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}

circ <- circleFun(c(0,0),2,npoints = 500)

#Now we can make our initial plot of the PCA.
g %>% 
  pivot_longer(cols = 8:26, names_to = "Gene", values_to = "gene_expression")  %>%
  ggplot(aes(x = pc1, y = pc2, color = challenge_infection, shape = challenge_infection)) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
  geom_point(alpha = 0.8) +
  stat_ellipse(geom="polygon", aes(fill = challenge_infection), alpha = 0.2, show.legend = FALSE,
               level = 0.95) +
  theme_minimal() +
  theme(panel.grid = element_blank(), panel.border = element_rect(fill= "transparent"))

```
```{r}
#It’s possible to use the function corrplot() [corrplot package] to highlight the most contributing variables for each dimension:
var.contrib <- res.pca$var$contrib
corrplot(var.contrib, is.corr=FALSE) 
```

The function fviz_contrib() [factoextra package] can be used to draw a bar plot of variable contributions. If your data contains many variables, you can decide to show only the top contributing variables. The R code below shows the top 10 variables contributing to the principal components:
```{r}
# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 18)
# Contributions of variables to PC2
fviz_contrib(res.pca, choice = "var", axes = 2, top = 18)
```
The total contribution to PC1 and PC2 is obtained with the following R code:
```{r}
fviz_contrib(res.pca, choice = "var", axes = 1:2, top = 18)
```
The red dashed line on the graph above indicates the expected average contribution. If the contribution of the variables were uniform, the expected value would be 1/length(variables) = 1/10 = 10%. For a given component, a variable with a contribution larger than this cutoff could be considered as important in contributing to the component.

Note that, the total contribution of a given variable, on explaining the variations retained by two principal components, say PC1 and PC2, is calculated as contrib = [(C1 * Eig1) + (C2 * Eig2)]/(Eig1 + Eig2), where

C1 and C2 are the contributions of the variable on PC1 and PC2, respectively
Eig1 and Eig2 are the eigenvalues of PC1 and PC2, respectively. Recall that eigenvalues measure the amount of variation retained by each PC.
In this case, the expected average contribution (cutoff) is calculated as follow: As mentioned above, if the contributions of the 10 variables were uniform, the expected average contribution on a given PC would be 1/10 = 10%. The expected average contribution of a variable for PC1 and PC2 is : [(10* Eig1) + (10 * Eig2)]/(Eig1 + Eig2)


```{r}
#The most important (or, contributing) variables can be highlighted on the correlation plot as follow:
fviz_pca_var(res.pca, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
             )
```
To visualize the contribution of individuals to the first two principal components, type this:

```{r}
# Total contribution on PC1 and PC2
fviz_contrib(res.pca, choice = "ind", axes = 1:2)
```
```{r}
fviz_pca_ind(res.pca,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = g$challenge_infection, # color by groups
             palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, # Concentration ellipses
             legend.title = "Groups"
             )

# Add confidence ellipses
fviz_pca_ind(res.pca, geom.ind = "point", col.ind = g$challenge_infection, 
             palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence",
             legend.title = "Groups"
             )
```

PCA + Biplot combination
```{r}
fviz_pca_biplot(res.pca, 
                col.ind = g$challenge_infection, palette = "jco", 
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Parasite in the challenge infection") 
```
 In the following example, we want to color both individuals and variables by groups. The trick is to use pointshape = 21 for individual points. This particular point shape can be filled by a color using the argument fill.ind. The border line color of individual points is set to “black” using col.ind. To color variable by groups, the argument col.var will be used.

To customize individuals and variable colors, we use the helper functions fill_palette() and color_palette() [in ggpubr package].

```{r}
fviz_pca_biplot(res.pca, 
                # Fill individuals by groups
                geom.ind = "point",
                pointshape = 21,
                pointsize = 2.5,
                fill.ind = g$challenge_infection,
                col.ind = "black",
                # Color variable by groups,
                legend.title = list(fill = "Parasite in challenge infections", color = "Clusters"),
                repel = TRUE        # Avoid label overplotting
             )+
  ggpubr::fill_palette("jco")+      # Indiviual fill color
  ggpubr::color_palette("npg")      # Variable colors
```
```{r}
library(RColorBrewer)
fviz_pca_biplot(res.pca, 
                # Individuals
                geom.ind = "point",
                fill.ind = g$challenge_infection, col.ind = "black",
                pointshape = 21, pointsize = 2,
                palette = "jco",
                addEllipses = TRUE,
                # Variables
                alpha.var ="contrib", col.var = "contrib",
                gradient.cols = "RdBu",
                legend.title = list(fill = "Parasite in challenge infection", color = "Contrib",
                                    alpha = "Contrib")
                )
```



```{r}
weight_lm <- lm(max_WL ~ pc1 + pc2 + challenge_infection, data = g)

summary(weight_lm)

AIC(weight_lm)

weight_lm_exp_only <- lm(max_WL ~ pc1 + pc2, data = g)
summary(weight_lm_exp_only)

AIC(weight_lm, weight_lm_exp_only)
```



################################### FACS #######################################

```{r, echpo = FALSE, include= FALSE}
rm(basics_gene, circ, comp, g, gene_correlation, gene_expr, mi, nb, 
   pca.vars, pca.vars.m, res.NA.remove, res.pca, var.contrib)
```
```{r}

## vectors for selecting columns
CellCount.cols <- c("Position", "CD4", "Treg", "Div_Treg", "Treg17", "Th1", 
                    "Div_Th1", "Th17", "Div_Th17", "CD8", "Act_CD8", 
                    "Div_Act_CD8", "IFNy_CD4", "IFNy_CD8","Treg_prop", 
                    "IL17A_CD4")  


### Select the necessary columns (as shown in the vectors above)
#df_facs <- Challenge %>% select(basics, weight_loss, CellCount.cols)


### Select the measurements from the mesenterial lymphnodes
# The spleen measurements are not so plenty and not comparable to the mln 
# measurements
Challenge_facs  <- Challenge%>% filter(Position == "mLN")


### Drop the columns that contain nas in the column CD4 of the facs columns
FACS <- Challenge_facs  %>% drop_na("CD4")

### Prepare the annotation data frame for the heatmap
annotation_df <- FACS %>% 
  filter(infection == "challenge") %>%
  dplyr::select(c("EH_ID", "Parasite_challenge", "infection_history"))

### Data tidying for the heatmap function
FACS <- FACS  %>% 
  dplyr::select(c(EH_ID, CellCount.cols))

# turn the data frame into a matrix and transpose it. We want to have each cell 
# type as a row name 
FACS <- t(as.matrix(FACS))

#switch the matrix back to a data frame format
FACS <- as.data.frame(FACS)

# turn the first row into column names
FACS %>%
  row_to_names(row_number = 1) -> FACS

# Now further prepare the data frame for plotting by removing the first row
## and convert the column to row names with the cells 
FACS[-1, ] -> heatmap_data

# turn the columns to numeric other wise the heatmap function will not work
heatmap_data[] <- lapply(heatmap_data, function(x) as.numeric(as.character(x)))

### Prepare the annotation columns for the heatmap
rownames(annotation_df) <- annotation_df$EH_ID

# Match the row names to the heatmap data frame
rownames(annotation_df) <- colnames(FACS)

#remove the unecessary column
annotation_df <- annotation_df %>% dplyr::select(-EH_ID, )


facs_data <- Challenge_facs %>% 
   dplyr::select(c(EH_ID, primary_infection, challenge_infection, infection_history, mouse_strain, 
            max_WL, delta)) %>%
     inner_join((t(heatmap_data) %>% 
                   as.data.frame() 
                 %>% tibble::rownames_to_column("EH_ID")), 
                by = "EH_ID")
 
 facs_data <- facs_data %>%
     dplyr::mutate(Parasite_challenge = case_when(    
         challenge_infection == "E64" ~ "Eimeria ferrisi",
         challenge_infection == "E88" ~ "Eimeria falciformis",
         challenge_infection == "Eflab" ~ "E. falciformis",
         challenge_infection == "E139" ~ "Eimeria ferrisi",
         challenge_infection == "UNI" ~ "uninfected",
         TRUE ~ ""))
#plot the heatmap

heatmap_data %>% 
  pheatmap(annotation_col = annotation_df, scale = "row")


```
```{r}
# draw correlation between the genes
facs_correlation <-  as.matrix(cor(Challenge %>% 
                                     dplyr::select(CellCount.cols) %>% 
                                     filter(Position == "mLN") %>%
                                     dplyr::select(-Position), use="pairwise.complete.obs"))


# matrix of the p-value of the correlatio
p.mat <- cor.mtest(facs_correlation)

corrplot(facs_correlation, 
         method = "circle",  #method of the plot, "color" would show colour gradient
         tl.col = "black", tl.srt=45, #colour of labels and rotation
         col = brewer.pal(n = 8, name ="RdYlBu"), #colour of matrix
         order="hclust") #hclust reordering

```
```{r}

corrplot(facs_correlation, 
         method = "circle",  #method of the plot, "color" would show colour gradient
         tl.col = "black", tl.srt=45, #colour of labels and rotation
         col = brewer.pal(n = 8, name ="RdYlBu"), #colour of matrix
         order="hclust", #hclust reordering
         p.mat = p.mat, sig.level = 0.01, insig = "blank",
         addCoef.col = 'black') #Add significance level to the correlogram
#remove the values that are insignificant


```
```{r}
corrplot(facs_correlation, 
         method = "circle",  #method of the plot, "color" would show colour gradient
         tl.col = "black", tl.srt=45, #colour of labels and rotation
         col = brewer.pal(n = 8, name ="RdYlBu"), #colour of matrix
         order="hclust") #hclust reordering

```


```{r}
corrplot(facs_correlation, 
         method = "circle",  #method of the plot, "color" would show colour gradient
         tl.col = "black", tl.srt=45, #colour of labels and rotation
         col = brewer.pal(n = 8, name ="RdYlBu"), #colour of matrix
         order="hclust", #hclust reordering
         p.mat = p.mat, sig.level = 0.01, insig = "blank") #Add significance level to the correlogram
#remove the values that are insignificant
```
```{r, echo = FALSE, include = FALSE}
rm(annotation_df, facs_correlation, FACS, heatmap_data, p.mat)
```

###### PCA FACS ################################################################### 


```{r, echo = FALSE}

basics_facs <- as_tibble(Challenge) %>%
  dplyr::filter(infection == "challenge", dpi == "8") %>%
  dplyr::group_by(EH_ID, infection) %>%
  dplyr::select(c("EH_ID", "primary_infection", "challenge_infection", 
                  "infection_history", "mouse_strain", "hybrid_status", 
                  "Parasite_primary", "Parasite_challenge", "max_WL", "max_OOC",
                  CellCount.cols, "delta"))

# remove duplicated and change the format to data frame 
basics_facs <- unique(basics_facs) %>%
  as.data.frame(basics_facs) %>%
  dplyr::select(-infection)


basics_facs %>%
    pivot_longer(cols = 12:26, names_to = "Cell", values_to = "Proportion") %>%
    na.omit(delta) %>%
    ggplot(aes(x = delta, y = Proportion, color = Parasite_challenge)) +
    geom_jitter() +
    facet_wrap(~ Cell, scales = "free") +
    theme_light() +
    labs(x = "Delta Ct, Infection intensity", y = "Cell Proportion",
         title = "FACS in response to infection intensity") +
    theme_bw()

```


```{r, echo = FALSE}
basics_facs %>%
    group_by(EH_ID) %>%
  pivot_longer(cols = 12:26, names_to = "Cell", values_to = "Proportion") %>%
  na.omit(Proportion) %>%
  ggplot(aes(x = Parasite_challenge, y = Proportion, color = Parasite_challenge)) + 
  geom_boxplot() +
  geom_jitter() +
  facet_wrap(~ Cell) +
  theme_bw() +
    labs(x = "Parasite strain",
         title = "FACS data in response to parasite strain") 
```
```{r}
basics_facs %>%
    group_by(EH_ID) %>%
  pivot_longer(cols = 12:26, names_to = "Cell", values_to = "Proportion") %>%
  ggplot(aes(x = Proportion, color = Parasite_challenge)) + 
  geom_histogram()

basics_facs %>%
  dplyr::group_by(EH_ID) %>%
  filter(!challenge_infection == "UNI") %>%
  pivot_longer(cols = 12:26, names_to = "Cell", values_to = "Proportion") %>%
  ggplot(aes(x = Proportion, color = challenge_infection)) + 
  geom_histogram()
```
```{r}
summary(basics_facs)
f <- basics_facs

```


```{r, echo = FALSE}
#Make a scatter plot matrix showing the correlation coefficients between variables and the significance levels : the package PerformanceAnalytics is required.
library(PerformanceAnalytics)
chart.Correlation(f[12:26], histogram=TRUE, pch=19)
```


```{r}
## let's try a pca without imputing the missing values , 
# the function imputes the missing values by the mean of the variable to which 
# they belong
glimpse(f)
res.pca <- PCA(f[12:26])
```
```{r}
#let's do a pca while removing ALL NA values
res.NA.remove <- PCA(f[12:26] %>% na.omit())

# These are rather unsophisticated ways to solve the problem

```

We will now continue by using an iterative pca to impute missing data 
 A. Initialization: impute using the mean
 B. Step lampda:
  # a. do pca on imputed data table S dimensions retained
  # b. missing data imputed using pca
  # c. means (and standard deviations) updated
 C. Iterate the estimation and imputation steps (until convergence)
(convergence: the act of converging and especially moving toward union or uniformity)

Overfitting is a common problem due to believing too much in links between variables. 
--> regularized iterative PCA (This version is what is being implented in missMDA)
This is a way of taking less risk when imputing the missing data. 
The algorithm estimates the missing data values with values that have no influence
on the PCA results, i.e., no influence on the coordinates of the individals or variables. 

```{r}
## 1. Estimate the number of dimensions necessary to impute the dataset 
# with the estim_ncpPCA
nb <- estim_ncpPCA(f[12:26], scale = TRUE) 
# Each observed value is removed, then imputed using ncp components
# The difference between the ovserved value and the imputed value is calculated 
# ncp = 5

## 2. Imputation of the missing values using the function impute PCA
comp <- imputePCA(f[12:26], ncp = 5, scale = TRUE) #impute the table
head(comp$completeObs) # resulting imputed data table
# this estimate should be better than simply using the mean, beacause we've taken into account
# the links between variables and similarities between individuals in its calculation

options(ggrepel.max.overlaps = Inf) # solution to the error: 
# ggrepel: 3 unlabeled data points (too many overlaps). Consider increasing max.overlaps 
# for the next function

# we can now run a normal pca on the complete data set
res.pca <- PCA(comp$completeObs)
head(summary(res.pca, nbelements = Inf)) #including all the elements
```
```{r}
#Description of the dimensions
# We get a correlation between each variable and the first dimension
dimdesc(res.pca)
```


Caution: When imputing data, the percentages of inertia associated with the first dimensions will be overestimated.

Another problem: the imputed data are, when the pca is performed considered like real observations.
But they are estimations!! 

Visualizing uncertainty due to issing data:

--> mulrimple imputation: generate several plausible values for each missing data point

We here visualize the variability, that is uncertainty on the plane defined by two pca axes. 
```{r}
#Visualizing uncertainty due to missing data:

mi <- MIPCA(f[12:26], scale = TRUE, ncp = 5)
plot(mi)
```
Individuals lying on the axis have no missing data, but individuals that far away have many missing data. 
big ellipse = big uncertainty
tight elipse (line) = low uncertainty

Variable representation: 
Poins tight together )look like one) - have no missing variables --> low uncertainty
Points spread -- > higher variability -- > higher uncertainty


High uncertainty--> we should interpret the result with care

The individuals with many missing data values make the axes move, 
and thus the positions of all individuals

Therefore in the last plots every individual is getting an eclipse as they are as well influenced by the missing data of the others. 


THe plot with the dimensions shows the projections of the pca dimensions of each imputed table on the pca plane obtained using the original imputed data table

As all of the arrows are close to either the first or second axes, 
this means that the axes are stable with respect to the set of imputed tables --> we don't have evidence of instability here.

```{r, echo = FALSE, include = FALSE}
str(res.pca)
```

```{r}
library(factoextra)
library(MASS)
library(reshape2)
library(cowplot)
# extract pc scores for first two component and add to dat dataframe
g$pc1 <- res.pca$ind$coord[, 1] # indexing the first column

g$pc2 <- res.pca$ind$coord[, 2]  # indexing the second column

#We also need to extract the data for the variable contributions to each of the pc axes.
pca.vars <- res.pca$var$coord %>% data.frame
pca.vars$vars <- rownames(pca.vars)
pca.vars.m <- melt(pca.vars, id.vars = "vars")


#By convention, the variable contribution plot has a circle around the variables that has a radius of 1. Here’s some code to make one.
circleFun <- function(center = c(0,0),diameter = 1, npoints = 100){
  r = diameter / 2
  tt <- seq(0,2*pi,length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}

circ <- circleFun(c(0,0),2,npoints = 500)

#Now we can make our initial plot of the PCA.
g %>% 
  pivot_longer(cols = 8:26, names_to = "Gene", values_to = "gene_expression")  %>%
  ggplot(aes(x = pc1, y = pc2, color = challenge_infection, shape = challenge_infection)) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
  geom_point(alpha = 0.8) +
  stat_ellipse(geom="polygon", aes(fill = challenge_infection), alpha = 0.2, show.legend = FALSE,
               level = 0.95) +
  theme_minimal() +
  theme(panel.grid = element_blank(), panel.border = element_rect(fill= "transparent"))

```
```{r}
#It’s possible to use the function corrplot() [corrplot package] to highlight the most contributing variables for each dimension:
var.contrib <- res.pca$var$contrib
corrplot(var.contrib, is.corr=FALSE) 
```

The function fviz_contrib() [factoextra package] can be used to draw a bar plot of variable contributions. If your data contains many variables, you can decide to show only the top contributing variables. The R code below shows the top 10 variables contributing to the principal components:
```{r}
# Contributions of variables to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 18)
# Contributions of variables to PC2
fviz_contrib(res.pca, choice = "var", axes = 2, top = 18)
```
The total contribution to PC1 and PC2 is obtained with the following R code:
```{r}
fviz_contrib(res.pca, choice = "var", axes = 1:2, top = 18)
```
The red dashed line on the graph above indicates the expected average contribution. If the contribution of the variables were uniform, the expected value would be 1/length(variables) = 1/10 = 10%. For a given component, a variable with a contribution larger than this cutoff could be considered as important in contributing to the component.

Note that, the total contribution of a given variable, on explaining the variations retained by two principal components, say PC1 and PC2, is calculated as contrib = [(C1 * Eig1) + (C2 * Eig2)]/(Eig1 + Eig2), where

C1 and C2 are the contributions of the variable on PC1 and PC2, respectively
Eig1 and Eig2 are the eigenvalues of PC1 and PC2, respectively. Recall that eigenvalues measure the amount of variation retained by each PC.
In this case, the expected average contribution (cutoff) is calculated as follow: As mentioned above, if the contributions of the 10 variables were uniform, the expected average contribution on a given PC would be 1/10 = 10%. The expected average contribution of a variable for PC1 and PC2 is : [(10* Eig1) + (10 * Eig2)]/(Eig1 + Eig2)


```{r}
#The most important (or, contributing) variables can be highlighted on the correlation plot as follow:
fviz_pca_var(res.pca, col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07")
             )
```
To visualize the contribution of individuals to the first two principal components, type this:

```{r}
# Total contribution on PC1 and PC2
fviz_contrib(res.pca, choice = "ind", axes = 1:2)
```
```{r}
fviz_pca_ind(res.pca,
             geom.ind = "point", # show points only (nbut not "text")
             col.ind = g$challenge_infection, # color by groups
             palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, # Concentration ellipses
             legend.title = "Groups"
             )

# Add confidence ellipses
fviz_pca_ind(res.pca, geom.ind = "point", col.ind = g$challenge_infection, 
             palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence",
             legend.title = "Groups"
             )
```

PCA + Biplot combination
```{r}
fviz_pca_biplot(res.pca, 
                col.ind = g$challenge_infection, palette = "jco", 
                addEllipses = TRUE, label = "var",
                col.var = "black", repel = TRUE,
                legend.title = "Parasite in the challenge infection") 
```
 In the following example, we want to color both individuals and variables by groups. The trick is to use pointshape = 21 for individual points. This particular point shape can be filled by a color using the argument fill.ind. The border line color of individual points is set to “black” using col.ind. To color variable by groups, the argument col.var will be used.

To customize individuals and variable colors, we use the helper functions fill_palette() and color_palette() [in ggpubr package].

```{r}
fviz_pca_biplot(res.pca, 
                # Fill individuals by groups
                geom.ind = "point",
                pointshape = 21,
                pointsize = 2.5,
                fill.ind = g$challenge_infection,
                col.ind = "black",
                # Color variable by groups,
                legend.title = list(fill = "Parasite in challenge infections", color = "Clusters"),
                repel = TRUE        # Avoid label overplotting
             )+
  ggpubr::fill_palette("jco")+      # Indiviual fill color
  ggpubr::color_palette("npg")      # Variable colors
```
```{r}
library(RColorBrewer)
fviz_pca_biplot(res.pca, 
                # Individuals
                geom.ind = "point",
                fill.ind = g$challenge_infection, col.ind = "black",
                pointshape = 21, pointsize = 2,
                palette = "jco",
                addEllipses = TRUE,
                # Variables
                alpha.var ="contrib", col.var = "contrib",
                gradient.cols = "RdBu",
                legend.title = list(fill = "Parasite in challenge infection", color = "Contrib",
                                    alpha = "Contrib")
                )
```



```{r}
weight_lm <- lm(max_WL ~ pc1 + pc2 + challenge_infection, data = g)

summary(weight_lm)

AIC(weight_lm)

weight_lm_exp_only <- lm(max_WL ~ pc1 + pc2, data = g)
summary(weight_lm_exp_only)

AIC(weight_lm, weight_lm_exp_only)
```
